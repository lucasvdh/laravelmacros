{"version":3,"sources":["jquery.inputmask.min.js","chosen.jquery.min.js","tags-input.js","bootstrap-datepicker.js","laravel-macros-app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpoGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7xCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"laravel-macros.js","sourcesContent":["/**\n* @license Input Mask plugin for jquery\n* http://github.com/RobinHerbots/jquery.inputmask\n* Copyright (c) 2010 - 2014 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.0.56\n*/\n\n(function ($) {\n    if ($.fn.inputmask === undefined) {\n\n        //helper functions\n        function isInputEventSupported(eventName) {\n            var el = document.createElement('input'),\n                eventName = 'on' + eventName,\n                isSupported = (eventName in el);\n            if (!isSupported) {\n                el.setAttribute(eventName, 'return;');\n                isSupported = typeof el[eventName] == 'function';\n            }\n            el = null;\n            return isSupported;\n        }\n\n        function resolveAlias(aliasStr, options, opts) {\n            var aliasDefinition = opts.aliases[aliasStr];\n            if (aliasDefinition) {\n                if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\n                $.extend(true, opts, aliasDefinition); //merge alias definition in the options\n                $.extend(true, opts, options); //reapply extra given options\n                return true;\n            }\n            return false;\n        }\n\n        function generateMaskSet(opts) {\n            var ms = [];\n\n            function analyseMask(mask) {\n                var tokenizer = /(?:[?*+]|\\{[0-9\\+\\*]+(?:,[0-9\\+\\*]*)?\\})\\??|[^.?*+^${[]()|\\\\]+|./g,\n                    escaped = false;\n\n                function maskToken(isGroup, isOptional, isQuantifier, isAlternator) {\n                    this.matches = [];\n                    this.isGroup = isGroup || false;\n                    this.isOptional = isOptional || false;\n                    this.isQuantifier = isQuantifier || false;\n                    this.isAlternator = isAlternator || false;\n                    this.quantifier = { min: 1, max: 1 };\n                };\n\n                //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder}\n                function insertTestDefinition(mtoken, element, position) {\n                    var maskdef = opts.definitions[element];\n                    var newBlockMarker = mtoken.matches.length == 0;\n                    position = position != undefined ? position : mtoken.matches.length;\n                    if (maskdef && !escaped) {\n                        var prevalidators = maskdef[\"prevalidator\"], prevalidatorsL = prevalidators ? prevalidators.length : 0;\n                        for (var i = 1; i < maskdef.cardinality; i++) {\n                            var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator[\"validator\"], cardinality = prevalidator[\"cardinality\"];\n                            mtoken.matches.splice(position++, 0, { fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp(\".\"), cardinality: cardinality ? cardinality : 1, optionality: mtoken.isOptional, newBlockMarker: newBlockMarker, casing: maskdef[\"casing\"], def: maskdef[\"definitionSymbol\"] || element, placeholder: maskdef[\"placeholder\"] });\n                        }\n                        mtoken.matches.splice(position++, 0, { fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp(\".\"), cardinality: maskdef.cardinality, optionality: mtoken.isOptional, newBlockMarker: newBlockMarker, casing: maskdef[\"casing\"], def: maskdef[\"definitionSymbol\"] || element, placeholder: maskdef[\"placeholder\"] });\n                    } else {\n                        mtoken.matches.splice(position++, 0, { fn: null, cardinality: 0, optionality: mtoken.isOptional, newBlockMarker: newBlockMarker, casing: null, def: element, placeholder: undefined });\n                        escaped = false;\n                    }\n                }\n\n                var currentToken = new maskToken(),\n                    match,\n                    m,\n                    openenings = [],\n                    maskTokens = [];\n\n                while (match = tokenizer.exec(mask)) {\n                    m = match[0];\n                    switch (m.charAt(0)) {\n                        case opts.optionalmarker.end:\n                            // optional closing\n                        case opts.groupmarker.end:\n                            // Group closing\n                            var openingToken = openenings.pop();\n                            if (openenings.length > 0) {\n                                openenings[openenings.length - 1][\"matches\"].push(openingToken);\n                            } else {\n                                currentToken.matches.push(openingToken);\n                            }\n                            break;\n                        case opts.optionalmarker.start:\n                            // optional opening\n                            openenings.push(new maskToken(false, true));\n                            break;\n                        case opts.groupmarker.start:\n                            // Group opening\n                            openenings.push(new maskToken(true));\n                            break;\n                        case opts.quantifiermarker.start:\n                            //Quantifier\n                            var quantifier = new maskToken(false, false, true);\n\n                            m = m.replace(/[{}]/g, \"\");\n                            var mq = m.split(\",\"),\n                                mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\n                                mq1 = mq.length == 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\n                            if (mq1 == \"*\" || mq1 == \"+\") {\n                                mq0 = mq1 == \"*\" ? 0 : 1;\n                            }\n                            quantifier.quantifier = { min: mq0, max: mq1 };\n                            if (openenings.length > 0) {\n                                var matches = openenings[openenings.length - 1][\"matches\"];\n                                var match = matches.pop();\n                                if (!match[\"isGroup\"]) {\n                                    var groupToken = new maskToken(true);\n                                    groupToken.matches.push(match);\n                                    match = groupToken;\n                                }\n                                matches.push(match);\n                                matches.push(quantifier);\n                            } else {\n                                var match = currentToken.matches.pop();\n                                if (!match[\"isGroup\"]) {\n                                    var groupToken = new maskToken(true);\n                                    groupToken.matches.push(match);\n                                    match = groupToken;\n                                }\n                                currentToken.matches.push(match);\n                                currentToken.matches.push(quantifier);\n                            }\n                            break;\n                        case opts.escapeChar:\n                            escaped = true;\n                            break;\n                        case opts.alternatormarker:\n\n                            break;\n                        default:\n                            if (openenings.length > 0) {\n                                insertTestDefinition(openenings[openenings.length - 1], m);\n                            } else {\n                                if (currentToken.matches.length > 0) {\n                                    var lastMatch = currentToken.matches[currentToken.matches.length - 1];\n                                    if (lastMatch[\"isGroup\"]) { //this is not a group but a normal mask => convert\n                                        lastMatch.isGroup = false;\n                                        insertTestDefinition(lastMatch, opts.groupmarker.start, 0);\n                                        insertTestDefinition(lastMatch, opts.groupmarker.end);\n                                    }\n                                }\n                                insertTestDefinition(currentToken, m);\n                            }\n                    }\n                }\n\n                if (currentToken.matches.length > 0) {\n                    var lastMatch = currentToken.matches[currentToken.matches.length - 1];\n                    if (lastMatch[\"isGroup\"]) { //this is not a group but a normal mask => convert\n                        lastMatch.isGroup = false;\n                        insertTestDefinition(lastMatch, opts.groupmarker.start, 0);\n                        insertTestDefinition(lastMatch, opts.groupmarker.end);\n                    }\n                    maskTokens.push(currentToken);\n                }\n\n                //console.log(JSON.stringify(maskTokens));\n                return maskTokens;\n            }\n\n            function generateMask(mask, metadata) {\n                if (opts.numericInput && opts.multi !== true) { //TODO FIX FOR DYNAMIC MASKS WITH QUANTIFIERS\n                    mask = mask.split('').reverse();\n                    for (var ndx = 0; ndx < mask.length; ndx++) {\n                        if (mask[ndx] == opts.optionalmarker.start)\n                            mask[ndx] = opts.optionalmarker.end;\n                        else if (mask[ndx] == opts.optionalmarker.end)\n                            mask[ndx] = opts.optionalmarker.start;\n                        else if (mask[ndx] == opts.groupmarker.start)\n                            mask[ndx] = opts.groupmarker.end;\n                        else if (mask[ndx] == opts.groupmarker.end)\n                            mask[ndx] = opts.groupmarker.start;\n                    }\n                    mask = mask.join('');\n                }\n                if (mask == undefined || mask == \"\")\n                    return undefined;\n                else {\n                    if (opts.repeat > 0 || opts.repeat == \"*\" || opts.repeat == \"+\") {\n                        var repeatStart = opts.repeat == \"*\" ? 0 : (opts.repeat == \"+\" ? 1 : opts.repeat);\n                        mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + \",\" + opts.repeat + opts.quantifiermarker.end;\n                    }\n                    if ($.inputmask.masksCache[mask] == undefined) {\n                        $.inputmask.masksCache[mask] = {\n                            \"mask\": mask,\n                            \"maskToken\": analyseMask(mask),\n                            \"validPositions\": {},\n                            \"_buffer\": undefined,\n                            \"buffer\": undefined,\n                            \"tests\": {},\n                            \"metadata\": metadata\n                        };\n                    }\n\n                    return $.extend(true, {}, $.inputmask.masksCache[mask]);\n                }\n            }\n\n            if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\n                opts.mask = opts.mask.call(this, opts);\n            }\n            if ($.isArray(opts.mask)) {\n                $.each(opts.mask, function (ndx, msk) {\n                    if (msk[\"mask\"] != undefined) {\n                        ms.push(generateMask(msk[\"mask\"].toString(), msk));\n                    } else {\n                        ms.push(generateMask(msk.toString()));\n                    }\n                });\n            } else {\n                if (opts.mask.length == 1 && opts.greedy == false && opts.repeat != 0) {\n                    opts.placeholder = \"\";\n                } //hide placeholder with single non-greedy mask\n                if (opts.mask[\"mask\"] != undefined) {\n                    ms = generateMask(opts.mask[\"mask\"].toString(), opts.mask);\n                } else {\n                    ms = generateMask(opts.mask.toString());\n                }\n            }\n            return ms;\n        }\n\n        var msie1x = typeof ScriptEngineMajorVersion === \"function\"\n                ? ScriptEngineMajorVersion() //IE11 detection\n                : new Function(\"/*@cc_on return @_jscript_version; @*/\")() >= 10, //conditional compilation from mickeysoft trick\n            ua = navigator.userAgent,\n            iphone = ua.match(new RegExp(\"iphone\", \"i\")) !== null,\n            android = ua.match(new RegExp(\"android.*safari.*\", \"i\")) !== null,\n            androidchrome = ua.match(new RegExp(\"android.*chrome.*\", \"i\")) !== null,\n            androidfirefox = ua.match(new RegExp(\"android.*firefox.*\", \"i\")) !== null,\n            kindle = /Kindle/i.test(ua) || /Silk/i.test(ua) || /KFTT/i.test(ua) || /KFOT/i.test(ua) || /KFJWA/i.test(ua) || /KFJWI/i.test(ua) || /KFSOWI/i.test(ua) || /KFTHWA/i.test(ua) || /KFTHWI/i.test(ua) || /KFAPWA/i.test(ua) || /KFAPWI/i.test(ua),\n            PasteEventType = isInputEventSupported('paste') ? 'paste' : isInputEventSupported('input') ? 'input' : \"propertychange\";\n\n        //if (androidchrome) {\n        //    var browser = navigator.userAgent.match(new RegExp(\"chrome.*\", \"i\")),\n        //        version = parseInt(new RegExp(/[0-9]+/).exec(browser));\n        //    androidchrome32 = (version == 32);\n        //}\n\n        //masking scope\n        //actionObj definition see below\n        function maskScope(actionObj, maskset, opts) {\n            var isRTL = false,\n                valueOnFocus,\n                $el,\n                skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\n                skipInputEvent = false, //skip when triggered from within inputmask\n                ignorable = false,\n                maxLength;\n\n            //maskset helperfunctions\n\n\n            function getMaskTemplate(baseOnInput, minimalPos, includeInput) {\n                minimalPos = minimalPos || 0;\n                var maskTemplate = [], ndxIntlzr, pos = 0, test, testPos;\n                do {\n                    if (baseOnInput === true && getMaskSet()['validPositions'][pos]) {\n                        var validPos = getMaskSet()['validPositions'][pos];\n                        test = validPos[\"match\"];\n                        ndxIntlzr = validPos[\"locator\"].slice();\n                        maskTemplate.push(test[\"fn\"] == null ? test[\"def\"] : (includeInput === true ? validPos[\"input\"] : test[\"placeholder\"] || opts.placeholder.charAt(pos % opts.placeholder.length)));\n                    } else {\n                        if (minimalPos > pos) {\n                            var testPositions = getTests(pos, ndxIntlzr, pos - 1);\n                            testPos = testPositions[0];\n                        } else {\n                            testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n                        }\n                        test = testPos[\"match\"];\n                        ndxIntlzr = testPos[\"locator\"].slice();\n                        maskTemplate.push(test[\"fn\"] == null ? test[\"def\"] : test[\"placeholder\"] || opts.placeholder.charAt(pos % opts.placeholder.length));\n                    }\n                    pos++;\n                } while ((maxLength == undefined || pos - 1 < maxLength) && test[\"fn\"] != null || (test[\"fn\"] == null && test[\"def\"] != \"\") || minimalPos >= pos);\n                maskTemplate.pop(); //drop the last one which is empty\n                return maskTemplate;\n            }\n\n            function getMaskSet() {\n                return maskset;\n            }\n\n            function resetMaskSet(soft) {\n                var maskset = getMaskSet();\n                maskset[\"buffer\"] = undefined;\n                maskset[\"tests\"] = {};\n                if (soft !== true) {\n                    maskset[\"_buffer\"] = undefined;\n                    maskset[\"validPositions\"] = {};\n                    maskset[\"p\"] = -1;\n                }\n            }\n\n            function getLastValidPosition(closestTo) {\n                var maskset = getMaskSet(), lastValidPosition = -1, valids = maskset[\"validPositions\"];\n                if (closestTo == undefined) closestTo = -1;\n                var before = lastValidPosition, after = lastValidPosition;\n                for (var posNdx in valids) {\n                    var psNdx = parseInt(posNdx);\n                    if (closestTo == -1 || valids[psNdx][\"match\"].fn != null) {\n                        if (psNdx < closestTo) before = psNdx;\n                        if (psNdx >= closestTo) after = psNdx;\n                    }\n                }\n                lastValidPosition = (closestTo - before) > 1 || after < closestTo ? before : after;\n                return lastValidPosition;\n            }\n\n            function setValidPosition(pos, validTest, fromSetValid) {\n                if (opts.insertMode && getMaskSet()[\"validPositions\"][pos] != undefined && fromSetValid == undefined) {\n                    //reposition & revalidate others\n                    var positionsClone = $.extend(true, {}, getMaskSet()[\"validPositions\"]), lvp = getLastValidPosition(), i;\n                    for (i = pos; i <= lvp; i++) { //clear selection\n                        delete getMaskSet()[\"validPositions\"][i];\n                    }\n                    getMaskSet()[\"validPositions\"][pos] = validTest;\n                    var valid = true;\n                    for (i = pos; i <= lvp ; i++) {\n                        var t = positionsClone[i];\n                        if (t != undefined) {\n                            var j = t[\"match\"].fn == null ? i + 1 : seekNext(i);\n                            if (positionCanMatchDefinition(j, t[\"match\"].def)) {\n                                valid = valid && isValid(j, t[\"input\"], true, true) !== false;\n                            } else valid = false;\n                        }\n                        if (!valid) break;\n                    }\n\n                    if (!valid) {\n                        getMaskSet()[\"validPositions\"] = $.extend(true, {}, positionsClone);\n                        return false;\n                    }\n                } else\n                    getMaskSet()[\"validPositions\"][pos] = validTest;\n\n                return true;\n            }\n\n            function stripValidPositions(start, end) {\n                var i, startPos = start, lvp;\n                for (i = start; i < end; i++) { //clear selection\n                    //TODO FIXME BETTER CHECK\n                    delete getMaskSet()[\"validPositions\"][i];\n                }\n\n                for (i = end ; i <= getLastValidPosition() ;) {\n                    var t = getMaskSet()[\"validPositions\"][i];\n                    var s = getMaskSet()[\"validPositions\"][startPos];\n                    if (t != undefined && s == undefined) {\n                        if (positionCanMatchDefinition(startPos, t.match.def) && isValid(startPos, t[\"input\"], true) !== false) {\n                            delete getMaskSet()[\"validPositions\"][i];\n                            i++;\n                        }\n                        startPos++;\n                    } else i++;\n                }\n                lvp = getLastValidPosition();\n                //catchup\n                while (lvp > 0 && (getMaskSet()[\"validPositions\"][lvp] == undefined || getMaskSet()[\"validPositions\"][lvp].match.fn == null)) {\n                    delete getMaskSet()[\"validPositions\"][lvp];\n                    lvp--;\n                }\n                resetMaskSet(true);\n            }\n\n            function getTestTemplate(pos, ndxIntlzr, tstPs) {\n                var testPositions = getTests(pos, ndxIntlzr, tstPs), testPos;\n                for (var ndx = 0; ndx < testPositions.length; ndx++) {\n                    testPos = testPositions[ndx];\n                    if (opts.greedy || (testPos[\"match\"] && (testPos[\"match\"].optionality === false || testPos[\"match\"].newBlockMarker === false) && testPos[\"match\"].optionalQuantifier !== true)) {\n                        break;\n                    }\n                }\n\n                return testPos;\n            }\n            function getTest(pos) {\n                if (getMaskSet()['validPositions'][pos]) {\n                    return getMaskSet()['validPositions'][pos][\"match\"];\n                }\n                return getTests(pos)[0][\"match\"];\n            }\n            function positionCanMatchDefinition(pos, def) {\n                var valid = false, tests = getTests(pos);\n                for (var tndx = 0; tndx < tests.length; tndx++) {\n                    if (tests[tndx][\"match\"] && tests[tndx][\"match\"].def == def) {\n                        valid = true;\n                        break;\n                    }\n                }\n                return valid;\n            };\n            function getTests(pos, ndxIntlzr, tstPs) {\n                var maskTokens = getMaskSet()[\"maskToken\"], testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr || [0], matches = [], insertStop = false;\n                function ResolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitilizer contains a set of indexes to speedup searches in the mtokens\n\n                    function handleMatch(match, loopNdx, quantifierRecurse) {\n                        if (testPos == pos && match.matches == undefined) {\n                            matches.push({ \"match\": match, \"locator\": loopNdx.reverse() });\n                            return true;\n                        } else if (match.matches != undefined) {\n                            if (match.isGroup && quantifierRecurse !== true) { //when a group pass along to the quantifier\n                                match = handleMatch(maskToken.matches[tndx + 1], loopNdx);\n                                if (match) return true;\n                            } else if (match.isOptional) {\n                                var optionalToken = match;\n                                match = ResolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\n                                if (match) {\n                                    var latestMatch = matches[matches.length - 1][\"match\"];\n                                    var isFirstMatch = $.inArray(latestMatch, optionalToken.matches) == 0;\n                                    if (isFirstMatch) {\n                                        insertStop = true; //insert a stop for non greedy\n                                    }\n                                    testPos = pos; //match the position after the group\n                                }\n                            } else if (match.isAlternator) {\n                                //TODO\n                            } else if (match.isQuantifier && quantifierRecurse !== true) {\n                                var qt = match;\n                                opts.greedy = opts.greedy && isFinite(qt.quantifier.max); //greedy must be off when * or + is used (always!!)\n                                for (var qndx = (ndxInitializer.length > 0 && quantifierRecurse !== true) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\n                                    var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\n                                    match = handleMatch(tokenGroup, [qndx].concat(loopNdx), true);\n                                    if (match) {\n                                        //get latest match\n                                        var latestMatch = matches[matches.length - 1][\"match\"];\n                                        latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1;\n                                        var isFirstMatch = $.inArray(latestMatch, tokenGroup.matches) == 0;\n\n                                        if (isFirstMatch) { //search for next possible match\n                                            if (qndx > qt.quantifier.min - 1) {\n                                                insertStop = true;\n                                                testPos = pos; //match the position after the group\n                                                break; //stop quantifierloop\n                                            } else return true;\n                                        } else {\n                                            return true;\n                                        }\n                                    }\n                                }\n                            } else {\n                                match = ResolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\n                                if (match)\n                                    return true;\n                            }\n                        } else testPos++;\n                    }\n\n                    for (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0) ; tndx < maskToken.matches.length; tndx++) {\n                        if (maskToken.matches[tndx][\"isQuantifier\"] !== true) {\n                            var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\n                            if (match && testPos == pos) {\n                                return match;\n                            } else if (testPos > pos) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                //if (disableCache !== true && getMaskSet()['tests'][pos] && !getMaskSet()['validPositions'][pos]) {\n                //    return getMaskSet()['tests'][pos];\n                //}\n                if (ndxIntlzr == undefined) {\n                    var previousPos = pos - 1, test;\n                    while ((test = getMaskSet()['validPositions'][previousPos]) == undefined && previousPos > -1) {\n                        previousPos--;\n                    }\n                    if (test != undefined && previousPos > -1) {\n                        testPos = previousPos;\n                        ndxInitializer = test[\"locator\"].slice();\n                    } else {\n                        previousPos = pos - 1;\n                        while ((test = getMaskSet()['tests'][previousPos]) == undefined && previousPos > -1) {\n                            previousPos--;\n                        }\n                        if (test != undefined && previousPos > -1) {\n                            testPos = previousPos;\n                            ndxInitializer = test[0][\"locator\"].slice();\n                        }\n                    }\n                }\n                for (var mtndx = ndxInitializer.shift() ; mtndx < maskTokens.length; mtndx++) {\n                    var match = ResolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\n                    if ((match && testPos == pos) || testPos > pos) {\n                        break;\n                    }\n                }\n                if (matches.length == 0 || insertStop)\n                    matches.push({ \"match\": { fn: null, cardinality: 0, optionality: true, casing: null, def: \"\" }, \"locator\": [] });\n\n                getMaskSet()['tests'][pos] = matches;\n                //console.log(pos + \" - \" + JSON.stringify(matches));\n                return matches;\n            }\n\n            function getBufferTemplate() {\n                if (getMaskSet()['_buffer'] == undefined) {\n                    //generate template\n                    getMaskSet()[\"_buffer\"] = getMaskTemplate(false, 1);\n                }\n                return getMaskSet()['_buffer'];\n            }\n\n            function getBuffer() {\n                if (getMaskSet()['buffer'] == undefined) {\n                    getMaskSet()['buffer'] = getMaskTemplate(true, getLastValidPosition(), true);\n                }\n                return getMaskSet()['buffer'];\n            }\n\n            function refreshFromBuffer(start, end) {\n                var buffer = getBuffer().slice(); //work on clone\n                if (start === true) {\n                    resetMaskSet();\n                    start = 0;\n                    end = buffer.length;\n                } else {\n                    for (var i = start; i < end; i++) {\n                        delete getMaskSet()[\"validPositions\"][i];\n                        delete getMaskSet()[\"tests\"][i];\n                    }\n                }\n\n                for (var i = start; i < end; i++) {\n                    if (buffer[i] != opts.skipOptionalPartCharacter) {\n                        isValid(i, buffer[i], true, true);\n                    }\n                }\n            }\n\n            function casing(elem, test) {\n                switch (test.casing) {\n                    case \"upper\":\n                        elem = elem.toUpperCase();\n                        break;\n                    case \"lower\":\n                        elem = elem.toLowerCase();\n                        break;\n                }\n\n                return elem;\n            }\n\n            function isValid(pos, c, strict, fromSetValid) { //strict true ~ no correction or autofill\n                strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions \n\n                function _isValid(position, c, strict, fromSetValid) {\n                    var rslt = false;\n                    $.each(getTests(position), function (ndx, tst) {\n                        var test = tst[\"match\"];\n                        var loopend = c ? 1 : 0, chrs = '', buffer = getBuffer();\n                        for (var i = test.cardinality; i > loopend; i--) {\n                            chrs += getBufferElement(position - (i - 1));\n                        }\n                        if (c) {\n                            chrs += c;\n                        }\n\n                        //return is false or a json object => { pos: ??, c: ??} or true\n                        rslt = test.fn != null ?\n                            test.fn.test(chrs, getMaskSet(), position, strict, opts)\n                            : (c == test[\"def\"] || c == opts.skipOptionalPartCharacter) && test[\"def\"] != \"\" ? //non mask\n                            { c: test[\"def\"], pos: position }\n                            : false;\n\n                        if (rslt !== false) {\n                            var elem = rslt.c != undefined ? rslt.c : c;\n                            elem = (elem == opts.skipOptionalPartCharacter && test[\"fn\"] === null) ? test[\"def\"] : elem;\n\n                            var validatedPos = position;\n                            if (rslt[\"remove\"] != undefined) { //remove position\n                                stripValidPositions(rslt[\"remove\"], rslt[\"remove\"] + 1);\n                            }\n\n                            if (rslt[\"refreshFromBuffer\"]) {\n                                var refresh = rslt[\"refreshFromBuffer\"];\n                                strict = true;\n                                refreshFromBuffer(refresh === true ? refresh : refresh[\"start\"], refresh[\"end\"]);\n                                if (rslt.pos == undefined && rslt.c == undefined) {\n                                    rslt.pos = getLastValidPosition();\n                                    return false;//breakout if refreshFromBuffer && nothing to insert\n                                }\n                                validatedPos = rslt.pos != undefined ? rslt.pos : position;\n                                if (validatedPos != position) {\n                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict\n                                    return false;\n                                }\n\n                            } else if (rslt !== true && rslt.pos != undefined && rslt[\"pos\"] != position) { //their is a position offset\n                                validatedPos = rslt[\"pos\"];\n                                refreshFromBuffer(position, validatedPos);\n                                if (validatedPos != position) {\n                                    rslt = $.extend(rslt, isValid(validatedPos, elem, true)); //revalidate new position strict\n                                    return false;\n                                }\n                            }\n\n                            if (rslt != true && rslt.pos == undefined && rslt.c == undefined) {\n                                return false; //breakout if nothing to insert\n                            }\n\n                            if (ndx > 0) {\n                                resetMaskSet(true);\n                            }\n\n                            if (!setValidPosition(validatedPos, $.extend({}, tst, { \"input\": casing(elem, test) }), fromSetValid))\n                                rslt = false;\n                            return false; //break from $.each\n                        }\n                    });\n\n                    return rslt;\n                }\n\n                //Check for a nonmask before the pos\n                var buffer = getBuffer();\n                for (var pndx = pos - 1; pndx > -1; pndx--) {\n                    if (getMaskSet()[\"validPositions\"][pndx] && getMaskSet()[\"validPositions\"][pndx].fn == null)\n                        break;\n                    else if ((!isMask(pndx) || buffer[pndx] != getPlaceholder(pndx)) && getTests(pndx).length > 1) {\n                        _isValid(pndx, buffer[pndx], true);\n                        break;\n                    }\n                }\n\n                var maskPos = pos;\n                if (maskPos >= getMaskLength()) return false;\n                var result = _isValid(maskPos, c, strict, fromSetValid);\n                if (!strict && result === false) {\n                    var currentPosValid = getMaskSet()[\"validPositions\"][maskPos];\n                    if (currentPosValid && currentPosValid[\"match\"].fn == null && (currentPosValid[\"match\"].def == c || c == opts.skipOptionalPartCharacter)) {\n                        result = { \"caret\": seekNext(maskPos) };\n                    } else if ((opts.insertMode || getMaskSet()[\"validPositions\"][seekNext(maskPos)] == undefined) && !isMask(maskPos)) { //does the input match on a further position?\n                        for (var nPos = maskPos + 1, snPos = seekNext(maskPos) ; nPos <= snPos; nPos++) {\n                            result = _isValid(nPos, c, strict, fromSetValid);\n                            if (result !== false) {\n                                maskPos = nPos;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (result === true) result = { \"pos\": maskPos };\n                return result;\n            }\n\n            function isMask(pos) {\n                var test = getTest(pos);\n                return test.fn != null ? test.fn : false;\n            }\n\n            function getMaskLength() {\n                var maskLength;\n                maxLength = $el.prop('maxLength');\n                if (maxLength == -1) maxLength = undefined; /* FF sets no defined max length to -1 */\n                if (opts.greedy == false) {\n                    var pos, lvp = getLastValidPosition(), testPos = getMaskSet()[\"validPositions\"][lvp],\n                        ndxIntlzr = testPos != undefined ? testPos[\"locator\"].slice() : undefined;\n                    for (pos = lvp + 1; testPos == undefined || (testPos[\"match\"][\"fn\"] != null || (testPos[\"match\"][\"fn\"] == null && testPos[\"match\"][\"def\"] != \"\")) ; pos++) {\n                        testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n                        ndxIntlzr = testPos[\"locator\"].slice();\n                    }\n                    maskLength = pos;\n                } else\n                    maskLength = getBuffer().length;\n\n                return (maxLength == undefined || maskLength < maxLength) ? maskLength : maxLength;\n            }\n\n            function seekNext(pos) {\n                var maskL = getMaskLength();\n                if (pos >= maskL) return maskL;\n                var position = pos;\n                while (++position < maskL && !isMask(position) && (opts.nojumps !== true || opts.nojumpsThreshold > position)) {\n                }\n                return position;\n            }\n\n            function seekPrevious(pos) {\n                var position = pos;\n                if (position <= 0) return 0;\n\n                while (--position > 0 && !isMask(position)) {\n                };\n                return position;\n            }\n\n            function getBufferElement(position) {\n                return getMaskSet()[\"validPositions\"][position] == undefined ? getPlaceholder(position) : getMaskSet()[\"validPositions\"][position][\"input\"];\n            }\n\n            function writeBuffer(input, buffer, caretPos) {\n                input._valueSet(buffer.join(''));\n                if (caretPos != undefined) {\n                    caret(input, caretPos);\n                }\n            }\n\n            function getPlaceholder(pos, test) {\n                test = test || getTest(pos);\n                return test[\"placeholder\"] || (test[\"fn\"] == null ? test[\"def\"] : opts.placeholder.charAt(pos % opts.placeholder.length));\n            }\n\n            function checkVal(input, writeOut, strict, nptvl, intelliCheck) {\n                var inputValue = nptvl != undefined ? nptvl.slice() : truncateInput(input._valueGet()).split('');\n                resetMaskSet();\n                if (writeOut) input._valueSet(\"\"); //initial clear\n                $.each(inputValue, function (ndx, charCode) {\n                    if (intelliCheck === true) {\n                        var p = getMaskSet()[\"p\"],\n                            lvp = p == -1 ? p : seekPrevious(p),\n                            pos = lvp == -1 ? ndx : seekNext(lvp);\n                        if ($.inArray(charCode, getBufferTemplate().slice(lvp + 1, pos)) == -1) {\n                            keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), false, strict, ndx);\n                        }\n                    } else {\n                        keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), false, strict, ndx);\n                        strict = strict || (ndx > 0 && ndx > getMaskSet()[\"p\"]);\n                    }\n                });\n                if (writeOut) {\n                    var keypressResult = opts.onKeyPress.call(this, undefined, getBuffer(), 0, opts);\n                    handleOnKeyResult(input, keypressResult);\n                    writeBuffer(input, getBuffer(), $(input).is(\":focus\") ? seekNext(getLastValidPosition(0)) : undefined);\n                }\n            }\n\n            function escapeRegex(str) {\n                return $.inputmask.escapeRegex.call(this, str);\n            }\n\n            function truncateInput(inputValue) {\n                return inputValue.replace(new RegExp(\"(\" + escapeRegex(getBufferTemplate().join('')) + \")*$\"), \"\");\n            }\n            function unmaskedvalue($input) {\n                if ($input.data('_inputmask') && !$input.hasClass('hasDatepicker')) {\n                    var umValue = [], vps = getMaskSet()[\"validPositions\"];\n                    for (var pndx in vps) {\n                        if (vps[pndx][\"match\"] && vps[pndx][\"match\"].fn != null) {\n                            umValue.push(vps[pndx][\"input\"]);\n                        }\n                    }\n                    var unmaskedValue = (isRTL ? umValue.reverse() : umValue).join('');\n                    var bufferValue = (isRTL ? getBuffer().reverse() : getBuffer()).join('');\n                    if ($.isFunction(opts.onUnMask)) {\n                        unmaskedValue = opts.onUnMask.call($input, bufferValue, unmaskedValue, opts);\n                    }\n                    return unmaskedValue;\n                } else {\n                    return $input[0]._valueGet();\n                }\n            }\n            function TranslatePosition(pos) {\n                if (isRTL && typeof pos == 'number' && (!opts.greedy || opts.placeholder != \"\")) {\n                    var bffrLght = getBuffer().length;\n                    pos = bffrLght - pos;\n                }\n                return pos;\n            }\n            function caret(input, begin, end) {\n                var npt = input.jquery && input.length > 0 ? input[0] : input, range;\n                if (typeof begin == 'number') {\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    end = (typeof end == 'number') ? end : begin;\n\n                    //store caret for multi scope\n                    var data = $(npt).data('_inputmask') || {};\n                    data[\"caret\"] = { \"begin\": begin, \"end\": end };\n                    $(npt).data('_inputmask', data);\n\n                    if (!$(npt).is(\":visible\")) {\n                        return;\n                    }\n\n                    npt.scrollLeft = npt.scrollWidth;\n                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode\n                    if (npt.setSelectionRange) {\n                        npt.selectionStart = begin;\n                        npt.selectionEnd = end;\n\n                    } else if (npt.createTextRange) {\n                        range = npt.createTextRange();\n                        range.collapse(true);\n                        range.moveEnd('character', end);\n                        range.moveStart('character', begin);\n                        range.select();\n                    }\n                } else {\n                    var data = $(npt).data('_inputmask');\n                    if (!$(npt).is(\":visible\") && data && data[\"caret\"] != undefined) {\n                        begin = data[\"caret\"][\"begin\"];\n                        end = data[\"caret\"][\"end\"];\n                    } else if (npt.setSelectionRange) {\n                        begin = npt.selectionStart;\n                        end = npt.selectionEnd;\n                    } else if (document.selection && document.selection.createRange) {\n                        range = document.selection.createRange();\n                        begin = 0 - range.duplicate().moveStart('character', -100000);\n                        end = begin + range.text.length;\n                    }\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    return { \"begin\": begin, \"end\": end };\n                }\n            }\n            function determineLastRequiredPosition(returnDefinition) {\n                var buffer = getBuffer(), bl = buffer.length,\n                   pos, lvp = getLastValidPosition(), positions = {},\n                   ndxIntlzr = getMaskSet()[\"validPositions\"][lvp] != undefined ? getMaskSet()[\"validPositions\"][lvp][\"locator\"].slice() : undefined, testPos;\n                for (pos = lvp + 1; pos < buffer.length; pos++) {\n                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n                    ndxIntlzr = testPos[\"locator\"].slice();\n                    positions[pos] = $.extend(true, {}, testPos);\n                }\n\n                for (pos = bl - 1; pos > lvp; pos--) {\n                    testPos = positions[pos][\"match\"];\n                    if ((testPos.optionality || testPos.optionalQuantifier) && buffer[pos] == getPlaceholder(pos, testPos)) {\n                        bl--;\n                    } else break;\n                }\n                return returnDefinition ? { \"l\": bl, \"def\": positions[bl] ? positions[bl][\"match\"] : undefined } : bl;\n            }\n            function clearOptionalTail(input) {\n                var buffer = getBuffer(), tmpBuffer = buffer.slice();\n                var rl = determineLastRequiredPosition();\n                tmpBuffer.length = rl;\n                writeBuffer(input, tmpBuffer);\n            }\n            function isComplete(buffer) { //return true / false / undefined (repeat *)\n                if ($.isFunction(opts.isComplete)) return opts.isComplete.call($el, buffer, opts);\n                if (opts.repeat == \"*\") return undefined;\n                var complete = false, lrp = determineLastRequiredPosition(true), aml = seekPrevious(lrp[\"l\"]), lvp = getLastValidPosition();\n\n                if (lvp == aml) {\n                    if (lrp[\"def\"] == undefined || lrp[\"def\"].newBlockMarker || lrp[\"def\"].optionalQuantifier) {\n                        complete = true;\n                        for (var i = 0; i <= aml; i++) {\n                            var mask = isMask(i);\n                            if ((mask && (buffer[i] == undefined || buffer[i] == getPlaceholder(i))) || (!mask && buffer[i] != getPlaceholder(i))) {\n                                complete = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return complete;\n            }\n\n            function isSelection(begin, end) {\n                return isRTL ? (begin - end) > 1 || ((begin - end) == 1 && opts.insertMode) :\n                (end - begin) > 1 || ((end - begin) == 1 && opts.insertMode);\n            }\n\n            function installEventRuler(npt) {\n                var events = $._data(npt).events;\n\n                $.each(events, function (eventType, eventHandlers) {\n                    $.each(eventHandlers, function (ndx, eventHandler) {\n                        if (eventHandler.namespace == \"inputmask\") {\n                            if (eventHandler.type != \"setvalue\") {\n                                var handler = eventHandler.handler;\n                                eventHandler.handler = function (e) {\n                                    if (this.readOnly || this.disabled)\n                                        e.preventDefault;\n                                    else\n                                        return handler.apply(this, arguments);\n                                };\n                            }\n                        }\n                    });\n                });\n            }\n\n            function patchValueProperty(npt) {\n\n                function PatchValhook(type) {\n                    if ($.valHooks[type] == undefined || $.valHooks[type].inputmaskpatch != true) {\n                        var valueGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) { return elem.value; };\n                        var valueSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\n                            elem.value = value;\n                            return elem;\n                        };\n\n                        $.valHooks[type] = {\n                            get: function (elem) {\n                                var $elem = $(elem);\n                                if ($elem.data('_inputmask')) {\n                                    if ($elem.data('_inputmask')['opts'].autoUnmask)\n                                        return $elem.inputmask('unmaskedvalue');\n                                    else {\n                                        var result = valueGet(elem),\n                                            inputData = $elem.data('_inputmask'),\n                                            maskset = inputData['maskset'],\n                                            bufferTemplate = maskset['_buffer'];\n                                        bufferTemplate = bufferTemplate ? bufferTemplate.join('') : '';\n                                        return result != bufferTemplate ? result : '';\n                                    }\n                                } else return valueGet(elem);\n                            },\n                            set: function (elem, value) {\n                                var $elem = $(elem), inputData = $elem.data('_inputmask'), result;\n                                if (inputData) {\n                                    result = valueSet(elem, $.isFunction(inputData['opts'].onBeforeMask) ? inputData['opts'].onBeforeMask.call(el, value, inputData['opts']) : value);\n                                    $elem.triggerHandler('setvalue.inputmask');\n                                } else {\n                                    result = valueSet(elem, value);\n                                }\n                                return result;\n                            },\n                            inputmaskpatch: true\n                        };\n                    }\n                }\n\n                var valueProperty;\n                if (Object.getOwnPropertyDescriptor)\n                    valueProperty = Object.getOwnPropertyDescriptor(npt, \"value\");\n                if (valueProperty && valueProperty.get) {\n                    if (!npt._valueGet) {\n                        var valueGet = valueProperty.get;\n                        var valueSet = valueProperty.set;\n                        npt._valueGet = function () {\n                            return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);\n                        };\n                        npt._valueSet = function (value) {\n                            valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);\n                        };\n\n                        Object.defineProperty(npt, \"value\", {\n                            get: function () {\n                                var $self = $(this), inputData = $(this).data('_inputmask');\n                                if (inputData) {\n                                    return inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : (valueGet.call(this) != getBufferTemplate().join('') ? valueGet.call(this) : '');\n                                } else return valueGet.call(this);\n                            },\n                            set: function (value) {\n                                var inputData = $(this).data('_inputmask');\n                                if (inputData) {\n                                    valueSet.call(this, $.isFunction(inputData['opts'].onBeforeMask) ? inputData['opts'].onBeforeMask.call(el, value, inputData['opts']) : value);\n                                    $(this).triggerHandler('setvalue.inputmask');\n                                } else {\n                                    valueSet.call(this, value);\n                                }\n                            }\n                        });\n                    }\n                } else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\n                    if (!npt._valueGet) {\n                        var valueGet = npt.__lookupGetter__(\"value\");\n                        var valueSet = npt.__lookupSetter__(\"value\");\n                        npt._valueGet = function () {\n                            return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);\n                        };\n                        npt._valueSet = function (value) {\n                            valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);\n                        };\n\n                        npt.__defineGetter__(\"value\", function () {\n                            var $self = $(this), inputData = $(this).data('_inputmask');\n                            if (inputData) {\n                                return inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : (valueGet.call(this) != getBufferTemplate().join('') ? valueGet.call(this) : '');\n                            } else return valueGet.call(this);\n                        });\n                        npt.__defineSetter__(\"value\", function (value) {\n                            var inputData = $(this).data('_inputmask');\n                            if (inputData) {\n                                valueSet.call(this, $.isFunction(inputData['opts'].onBeforeMask) ? inputData['opts'].onBeforeMask.call(el, value, inputData['opts']) : value);\n                                $(this).triggerHandler('setvalue.inputmask');\n                            } else {\n                                valueSet.call(this, value);\n                            }\n                        });\n                    }\n                } else {\n                    if (!npt._valueGet) {\n                        npt._valueGet = function () { return isRTL ? this.value.split('').reverse().join('') : this.value; };\n                        npt._valueSet = function (value) { this.value = isRTL ? value.split('').reverse().join('') : value; };\n                    }\n                    PatchValhook(npt.type);\n                }\n            }\n\n            function handleRemove(input, k, pos) {\n                if (opts.numericInput || isRTL) {\n                    if (k == opts.keyCode.BACKSPACE)\n                        k = opts.keyCode.DELETE;\n                    else if (k == opts.keyCode.DELETE)\n                        k = opts.keyCode.BACKSPACE;\n\n                    if (isRTL) {\n                        var pend = pos.end;\n                        pos.end = pos.begin;\n                        pos.begin = pend;\n                    }\n                }\n\n                if (k == opts.keyCode.BACKSPACE && pos.end - pos.begin <= 1)\n                    pos.begin = seekPrevious(pos.begin);\n                else if (k == opts.keyCode.DELETE && pos.begin == pos.end)\n                    pos.end++;\n\n                stripValidPositions(pos.begin, pos.end);\n                var firstMaskedPos = getLastValidPosition(pos.begin);\n                if (firstMaskedPos < pos.begin) {\n                    getMaskSet()[\"p\"] = seekNext(firstMaskedPos);\n                } else {\n                    getMaskSet()[\"p\"] = pos.begin;\n                }\n            }\n\n            function handleOnKeyResult(input, keyResult, caretPos) {\n                if (keyResult && keyResult[\"refreshFromBuffer\"]) {\n                    var refresh = keyResult[\"refreshFromBuffer\"];\n                    refreshFromBuffer(refresh === true ? refresh : refresh[\"start\"], refresh[\"end\"]);\n\n                    resetMaskSet(true);\n                    if (caretPos != undefined) {\n                        writeBuffer(input, getBuffer());\n                        caret(input, keyResult.caret || caretPos.begin, keyResult.caret || caretPos.end);\n                    }\n                }\n            }\n\n            function keydownEvent(e) {\n                //Safari 5.1.x - modal dialog fires keypress twice workaround\n                skipKeyPressEvent = false;\n                var input = this, $input = $(input), k = e.keyCode, pos = caret(input);\n\n                //backspace, delete, and escape get special treatment\n                if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127) || e.ctrlKey && k == 88) { //backspace/delete\n                    e.preventDefault(); //stop default action but allow propagation\n                    if (k == 88) valueOnFocus = getBuffer().join('');\n                    handleRemove(input, k, pos);\n                    writeBuffer(input, getBuffer(), getMaskSet()[\"p\"]);\n                    if (input._valueGet() == getBufferTemplate().join(''))\n                        $input.trigger('cleared');\n\n                    if (opts.showTooltip) { //update tooltip\n                        $input.prop(\"title\", getMaskSet()[\"mask\"]);\n                    }\n                } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\n                    setTimeout(function () {\n                        var caretPos = seekNext(getLastValidPosition());\n                        if (!opts.insertMode && caretPos == getMaskLength() && !e.shiftKey) caretPos--;\n                        caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);\n                    }, 0);\n                } else if ((k == opts.keyCode.HOME && !e.shiftKey) || k == opts.keyCode.PAGE_UP) { //Home or page_up\n                    caret(input, 0, e.shiftKey ? pos.begin : 0);\n                } else if (k == opts.keyCode.ESCAPE || (k == 90 && e.ctrlKey)) { //escape && undo\n                    checkVal(input, true, false, valueOnFocus.split(''));\n                    $input.click();\n                } else if (k == opts.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert\n                    opts.insertMode = !opts.insertMode;\n                    caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);\n                } else if (opts.insertMode == false && !e.shiftKey) {\n                    if (k == opts.keyCode.RIGHT) {\n                        setTimeout(function () {\n                            var caretPos = caret(input);\n                            caret(input, caretPos.begin);\n                        }, 0);\n                    } else if (k == opts.keyCode.LEFT) {\n                        setTimeout(function () {\n                            var caretPos = caret(input);\n                            caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);\n                        }, 0);\n                    }\n                }\n\n                var currentCaretPos = caret(input);\n                var keydownResult = opts.onKeyDown.call(this, e, getBuffer(), currentCaretPos.begin, opts);\n                handleOnKeyResult(input, keydownResult, currentCaretPos);\n                ignorable = $.inArray(k, opts.ignorables) != -1;\n            }\n\n            function keypressEvent(e, checkval, k, writeOut, strict, ndx) {\n                //Safari 5.1.x - modal dialog fires keypress twice workaround\n                if (k == undefined && skipKeyPressEvent) return false;\n                skipKeyPressEvent = true;\n\n                var input = this, $input = $(input);\n\n                e = e || window.event;\n                var k = checkval ? k : (e.which || e.charCode || e.keyCode);\n\n                if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\n                    return true;\n                } else {\n                    if (k) {\n                        //special treat the decimal separator\n                        if (checkval !== true && k == 46 && e.shiftKey == false && opts.radixPoint == \",\") k = 44;\n\n                        var pos, forwardPosition, c = String.fromCharCode(k);\n                        if (checkval) {\n                            var pcaret = strict ? ndx : getLastValidPosition() + 1;\n                            pos = { begin: pcaret, end: pcaret };\n                        } else {\n                            pos = caret(input);\n                        }\n\n                        //should we clear a possible selection??\n                        var isSlctn = isSelection(pos.begin, pos.end);\n                        if (isSlctn) {\n                            getMaskSet()[\"undoPositions\"] = $.extend(true, {}, getMaskSet()[\"validPositions\"]); //init undobuffer for recovery when not valid\n                            handleRemove(input, opts.keyCode.DELETE, pos);\n                            if (!opts.insertMode) { //preserve some space\n                                opts.insertMode = !opts.insertMode;\n                                setValidPosition(pos.begin, strict);\n                                opts.insertMode = !opts.insertMode;\n                            }\n                            isSlctn = !opts.multi;\n                        }\n\n                        getMaskSet()[\"writeOutBuffer\"] = true;\n                        var p = isRTL && !isSlctn ? pos.end : pos.begin;\n                        var valResult = isValid(p, c, strict);\n                        if (valResult !== false) {\n                            if (valResult !== true) {\n                                p = valResult.pos != undefined ? valResult.pos : p; //set new position from isValid\n                                c = valResult.c != undefined ? valResult.c : c; //set new char from isValid\n                            }\n                            resetMaskSet(true);\n                            if (valResult.caret != undefined)\n                                forwardPosition = valResult.caret;\n                            else {\n                                var vps = getMaskSet()[\"validPositions\"];\n                                if (vps[p + 1] != undefined && getTests(p + 1, vps[p].locator.slice(), p).length > 1)\n                                    forwardPosition = p + 1;\n                                else\n                                    forwardPosition = seekNext(p);\n                            }\n                            getMaskSet()[\"p\"] = forwardPosition; //needed for checkval\n                        }\n\n                        if (writeOut !== false) {\n                            var self = this;\n                            setTimeout(function () { opts.onKeyValidation.call(self, valResult, opts); }, 0);\n                            if (getMaskSet()[\"writeOutBuffer\"] && valResult !== false) {\n                                var buffer = getBuffer();\n                                writeBuffer(input, buffer, checkval ? undefined : opts.numericInput ? seekPrevious(forwardPosition) : forwardPosition);\n                                if (checkval !== true) {\n                                    setTimeout(function () { //timeout needed for IE\n                                        if (isComplete(buffer) === true)\n                                            $input.trigger(\"complete\");\n                                        skipInputEvent = true;\n                                        $input.trigger(\"input\");\n                                    }, 0);\n                                }\n                            } else if (isSlctn) {\n                                getMaskSet()[\"buffer\"] = undefined;\n                                getMaskSet()[\"validPositions\"] = getMaskSet()[\"undoPositions\"];\n                            }\n                        } else if (isSlctn) {\n                            getMaskSet()[\"buffer\"] = undefined;\n                            getMaskSet()[\"validPositions\"] = getMaskSet()[\"undoPositions\"];\n                        }\n\n\n                        if (opts.showTooltip) { //update tooltip\n                            $input.prop(\"title\", getMaskSet()[\"mask\"]);\n                        }\n\n                        //needed for IE8 and below\n                        if (e && checkval != true) {\n                            e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n                            var currentCaretPos = caret(input);\n                            var keypressResult = opts.onKeyPress.call(this, e, getBuffer(), currentCaretPos.begin, opts);\n                            handleOnKeyResult(input, keypressResult, currentCaretPos);\n                        }\n                        var temp;\n                        for (var i in getMaskSet().validPositions) {\n                            temp += \" \" + i;\n                        }\n                    }\n                }\n            }\n            function keyupEvent(e) {\n                var $input = $(this), input = this, k = e.keyCode, buffer = getBuffer();\n\n                var currentCaretPos = caret(input);\n                var keyupResult = opts.onKeyUp.call(this, e, buffer, currentCaretPos.begin, opts);\n                handleOnKeyResult(input, keyupResult, currentCaretPos);\n                if (k == opts.keyCode.TAB && opts.showMaskOnFocus) {\n                    if ($input.hasClass('focus-inputmask') && input._valueGet().length == 0) {\n                        resetMaskSet();\n                        buffer = getBuffer();\n                        writeBuffer(input, buffer);\n                        caret(input, 0);\n                        valueOnFocus = getBuffer().join('');\n                    } else {\n                        writeBuffer(input, buffer);\n                        caret(input, TranslatePosition(0), TranslatePosition(getMaskLength()));\n                    }\n                }\n            }\n            function pasteEvent(e) {\n                if (skipInputEvent === true && e.type == \"input\") {\n                    skipInputEvent = false;\n                    return true;\n                }\n\n                var input = this, $input = $(input), inputValue = input._valueGet();\n                //paste event for IE8 and lower I guess ;-)\n                if (e.type == \"propertychange\" && input._valueGet().length <= getMaskLength()) {\n                    return true;\n                } else if (e.type == \"paste\") {\n                    if (window.clipboardData && window.clipboardData.getData) { // IE\n                        inputValue = window.clipboardData.getData('Text');\n                    } else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {\n                        inputValue = e.originalEvent.clipboardData.getData('text/plain');\n                    }\n                }\n\n                var pasteValue = $.isFunction(opts.onBeforePaste) ? opts.onBeforePaste.call(input, inputValue, opts) : inputValue;\n                checkVal(input, true, false, pasteValue.split(''), true);\n                $input.click();\n                if (isComplete(getBuffer()) === true)\n                    $input.trigger(\"complete\");\n\n                return false;\n            }\n            function mobileInputEvent(e) {\n                if (skipInputEvent === true && e.type == \"input\") {\n                    skipInputEvent = false;\n                    return true;\n                }\n                var input = this;\n\n                //backspace in chrome32 only fires input event - detect & treat\n                var caretPos = caret(input),\n                    currentValue = input._valueGet();\n\n                currentValue = currentValue.replace(new RegExp(\"(\" + escapeRegex(getBufferTemplate().join('')) + \")*\"), \"\");\n                //correct caretposition for chrome\n                if (caretPos.begin > currentValue.length) {\n                    caret(input, currentValue.length);\n                    caretPos = caret(input);\n                }\n                if ((getBuffer().length - currentValue.length) == 1 && currentValue.charAt(caretPos.begin) != getBuffer()[caretPos.begin]\n                    && currentValue.charAt(caretPos.begin + 1) != getBuffer()[caretPos.begin]\n                    && !isMask(caretPos.begin)) {\n                    e.keyCode = opts.keyCode.BACKSPACE;\n                    keydownEvent.call(input, e);\n                }\n                e.preventDefault();\n            }\n\n            function mask(el) {\n                $el = $(el);\n                if ($el.is(\":input\") && $el.attr(\"type\") != \"number\") {\n                    //store tests & original buffer in the input element - used to get the unmasked value\n                    $el.data('_inputmask', {\n                        'maskset': maskset,\n                        'opts': opts,\n                        'isRTL': false\n                    });\n\n                    //show tooltip\n                    if (opts.showTooltip) {\n                        $el.prop(\"title\", getMaskSet()[\"mask\"]);\n                    }\n\n                    patchValueProperty(el);\n\n                    if (el.dir == \"rtl\" || opts.rightAlign)\n                        $el.css(\"text-align\", \"right\");\n\n                    if (el.dir == \"rtl\" || opts.numericInput) {\n                        el.dir = \"ltr\";\n                        $el.removeAttr(\"dir\");\n                        var inputData = $el.data('_inputmask');\n                        inputData['isRTL'] = true;\n                        $el.data('_inputmask', inputData);\n                        isRTL = true;\n                    }\n\n                    //unbind all events - to make sure that no other mask will interfere when re-masking\n                    $el.unbind(\".inputmask\");\n                    $el.removeClass('focus-inputmask');\n                    //bind events\n                    $el.closest('form').bind(\"submit\", function () { //trigger change on submit if any\n                        if (valueOnFocus != getBuffer().join('')) {\n                            $el.change();\n                        }\n                        if (opts.autoUnmask && opts.removeMaskOnSubmit) {\n                            $el.inputmask(\"remove\");\n                        }\n                    }).bind('reset', function () {\n                        setTimeout(function () {\n                            $el.trigger(\"setvalue\");\n                        }, 0);\n                    });\n                    $el.bind(\"mouseenter.inputmask\", function () {\n                        var $input = $(this), input = this;\n                        if (!$input.hasClass('focus-inputmask') && opts.showMaskOnHover) {\n                            if (input._valueGet() != getBuffer().join('')) {\n                                writeBuffer(input, getBuffer());\n                            }\n                        }\n                    }).bind(\"blur.inputmask\", function () {\n                        var $input = $(this), input = this;\n                        if ($input.data('_inputmask')) {\n                            var nptValue = input._valueGet(), buffer = getBuffer();\n                            $input.removeClass('focus-inputmask');\n                            if (valueOnFocus != getBuffer().join('')) {\n                                $input.change();\n                            }\n                            if (opts.clearMaskOnLostFocus && nptValue != '') {\n                                if (nptValue == getBufferTemplate().join(''))\n                                    input._valueSet('');\n                                else { //clearout optional tail of the mask\n                                    clearOptionalTail(input);\n                                }\n                            }\n                            if (isComplete(buffer) === false) {\n                                $input.trigger(\"incomplete\");\n                                if (opts.clearIncomplete) {\n                                    resetMaskSet();\n                                    if (opts.clearMaskOnLostFocus)\n                                        input._valueSet('');\n                                    else {\n                                        buffer = getBufferTemplate().slice();\n                                        writeBuffer(input, buffer);\n                                    }\n                                }\n                            }\n                        }\n                    }).bind(\"focus.inputmask\", function () {\n                        var $input = $(this), input = this, nptValue = input._valueGet();\n                        if (opts.showMaskOnFocus && !$input.hasClass('focus-inputmask') && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue == ''))) {\n                            if (input._valueGet() != getBuffer().join('')) {\n                                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\n                            }\n                        }\n                        $input.addClass('focus-inputmask');\n                        valueOnFocus = getBuffer().join('');\n                    }).bind(\"mouseleave.inputmask\", function () {\n                        var $input = $(this), input = this;\n                        if (opts.clearMaskOnLostFocus) {\n                            if (!$input.hasClass('focus-inputmask') && input._valueGet() != $input.attr(\"placeholder\")) {\n                                if (input._valueGet() == getBufferTemplate().join('') || input._valueGet() == '')\n                                    input._valueSet('');\n                                else { //clearout optional tail of the mask\n                                    //clearOptionalTail(input);\n                                }\n                            }\n                        }\n                    }).bind(\"click.inputmask\", function () {\n                        var input = this;\n                        if ($(input).is(\":focus\")) {\n                            setTimeout(function () {\n                                var selectedCaret = caret(input);\n                                if (selectedCaret.begin == selectedCaret.end) {\n                                    var clickPosition = isRTL ? TranslatePosition(selectedCaret.begin) : selectedCaret.begin,\n                                        lvp = getLastValidPosition(clickPosition),\n                                        lastPosition = seekNext(lvp);\n                                    if (clickPosition < lastPosition) {\n                                        if (isMask(clickPosition))\n                                            caret(input, clickPosition);\n                                        else caret(input, seekNext(clickPosition));\n                                    } else\n                                        caret(input, lastPosition);\n                                }\n                            }, 0);\n                        }\n                    }).bind('dblclick.inputmask', function () {\n                        var input = this;\n                        setTimeout(function () {\n                            caret(input, 0, seekNext(getLastValidPosition()));\n                        }, 0);\n                    }).bind(PasteEventType + \".inputmask dragdrop.inputmask drop.inputmask\", pasteEvent\n                    ).bind('setvalue.inputmask', function () {\n                        var input = this;\n                        checkVal(input, true);\n                        valueOnFocus = getBuffer().join('');\n                    }).bind('complete.inputmask', opts.oncomplete\n                    ).bind('incomplete.inputmask', opts.onincomplete\n                    ).bind('cleared.inputmask', opts.oncleared);\n\n                    $el.bind(\"keydown.inputmask\", keydownEvent\n                    ).bind(\"keypress.inputmask\", keypressEvent\n                    ).bind(\"keyup.inputmask\", keyupEvent);\n\n                    if (android || androidfirefox || androidchrome || kindle) {\n                        if (PasteEventType == \"input\") {\n                            $el.unbind(PasteEventType + \".inputmask\");\n                        }\n                        $el.bind(\"input.inputmask\", mobileInputEvent);\n                    }\n\n                    if (msie1x)\n                        $el.bind(\"input.inputmask\", pasteEvent);\n\n                    //apply mask\n                    var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(el, el._valueGet(), opts) : el._valueGet();\n                    checkVal(el, true, false, initialValue.split(''), true);\n                    valueOnFocus = getBuffer().join('');\n                    // Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\n                    var activeElement;\n                    try {\n                        activeElement = document.activeElement;\n                    } catch (e) {\n                    }\n                    if (isComplete(getBuffer()) === false) {\n                        if (opts.clearIncomplete)\n                            resetMaskSet();\n                    }\n                    if (opts.clearMaskOnLostFocus) {\n                        if (getBuffer().join('') == getBufferTemplate().join('')) {\n                            el._valueSet('');\n                        } else {\n                            clearOptionalTail(el);\n                        }\n                    } else {\n                        writeBuffer(el, getBuffer());\n                    }\n                    if (activeElement === el) { //position the caret when in focus\n                        $el.addClass('focus-inputmask');\n                        caret(el, seekNext(getLastValidPosition()));\n                    }\n\n                    installEventRuler(el);\n                }\n            }\n\n            //action object\n            if (actionObj != undefined) {\n                switch (actionObj[\"action\"]) {\n                    case \"isComplete\":\n                        $el = $(actionObj[\"el\"]);\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        return isComplete(actionObj[\"buffer\"]);\n                    case \"unmaskedvalue\":\n                        $el = actionObj[\"$input\"];\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        isRTL = actionObj[\"$input\"].data('_inputmask')['isRTL'];\n                        return unmaskedvalue(actionObj[\"$input\"]);\n                    case \"mask\":\n                        valueOnFocus = getBuffer().join('');\n                        mask(actionObj[\"el\"]);\n                        break;\n                    case \"format\":\n                        $el = $({});\n                        $el.data('_inputmask', {\n                            'maskset': maskset,\n                            'opts': opts,\n                            'isRTL': opts.numericInput\n                        });\n                        if (opts.numericInput) {\n                            isRTL = true;\n                        }\n                        var valueBuffer = actionObj[\"value\"].split('');\n                        checkVal($el, false, false, isRTL ? valueBuffer.reverse() : valueBuffer, true);\n                        return isRTL ? getBuffer().reverse().join('') : getBuffer().join('');\n                    case \"isValid\":\n                        $el = $({});\n                        $el.data('_inputmask', {\n                            'maskset': maskset,\n                            'opts': opts,\n                            'isRTL': opts.numericInput\n                        });\n                        if (opts.numericInput) {\n                            isRTL = true;\n                        }\n                        var valueBuffer = actionObj[\"value\"].split('');\n                        checkVal($el, false, true, isRTL ? valueBuffer.reverse() : valueBuffer);\n                        var buffer = getBuffer();\n                        var rl = determineLastRequiredPosition();\n                        buffer.length = rl;\n\n                        return isComplete(buffer) && actionObj[\"value\"] == buffer.join('');\n                    case \"getemptymask\":\n                        $el = $(actionObj[\"el\"]);\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        return getBufferTemplate();\n                    case \"remove\":\n                        var el = actionObj[\"el\"];\n                        $el = $(el);\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        //writeout the unmaskedvalue\n                        el._valueSet(unmaskedvalue($el));\n                        //unbind all events\n                        $el.unbind(\".inputmask\");\n                        $el.removeClass('focus-inputmask');\n                        //clear data\n                        $el.removeData('_inputmask');\n                        //restore the value property\n                        var valueProperty;\n                        if (Object.getOwnPropertyDescriptor)\n                            valueProperty = Object.getOwnPropertyDescriptor(el, \"value\");\n                        if (valueProperty && valueProperty.get) {\n                            if (el._valueGet) {\n                                Object.defineProperty(el, \"value\", {\n                                    get: el._valueGet,\n                                    set: el._valueSet\n                                });\n                            }\n                        } else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\n                            if (el._valueGet) {\n                                el.__defineGetter__(\"value\", el._valueGet);\n                                el.__defineSetter__(\"value\", el._valueSet);\n                            }\n                        }\n                        try { //try catch needed for IE7 as it does not supports deleting fns\n                            delete el._valueGet;\n                            delete el._valueSet;\n                        } catch (e) {\n                            el._valueGet = undefined;\n                            el._valueSet = undefined;\n\n                        }\n                        break;\n                }\n            }\n        };\n\n        $.inputmask = {\n            //options default\n            defaults: {\n                placeholder: \"_\",\n                optionalmarker: { start: \"[\", end: \"]\" },\n                quantifiermarker: { start: \"{\", end: \"}\" },\n                groupmarker: { start: \"(\", end: \")\" },\n                alternatormarker: \"|\",\n                escapeChar: \"\\\\\",\n                mask: null,\n                oncomplete: $.noop, //executes when the mask is complete\n                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost\n                oncleared: $.noop, //executes when the mask is cleared\n                repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\n                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\n                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\n                removeMaskOnSubmit: true, //remove the mask before submitting the form.  Use in combination with autoUnmask: true\n                clearMaskOnLostFocus: true,\n                insertMode: true, //insert the input or overwrite the input\n                clearIncomplete: false, //clear the incomplete input on blur\n                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js\n                alias: null,\n                onKeyUp: $.noop, //callback to implement autocomplete on certain keys for example\n                onKeyPress: $.noop, //callback to implement autocomplete on certain keys for example\n                onKeyDown: $.noop, //callback to implement autocomplete on certain keys for example\n                onBeforeMask: undefined, //executes before masking the initial value to allow preprocessing of the initial value.  args => initialValue, opts => return processedValue\n                onBeforePaste: undefined, //executes before masking the pasted value to allow preprocessing of the pasted value.  args => pastedValue, opts => return processedValue\n                onUnMask: undefined, //executes after unmasking to allow postprocessing of the unmaskedvalue.  args => maskedValue, unmaskedValue, opts\n                showMaskOnFocus: true, //show the mask-placeholder when the input has focus\n                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input\n                onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: result, opts\n                skipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\n                showTooltip: false, //show the activemask as tooltip\n                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\n                rightAlign: false, //align to the right\n                //numeric basic properties\n                radixPoint: \"\", //\".\", // | \",\"\n                //numeric basic properties\n                nojumps: false, //do not jump over fixed parts in the mask\n                nojumpsThreshold: 0, //start nojumps as of\n                definitions: {\n                    '9': {\n                        validator: \"[0-9]\",\n                        cardinality: 1,\n                        definitionSymbol: \"*\"\n                    },\n                    'a': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451]\",\n                        cardinality: 1,\n                        definitionSymbol: \"*\"\n                    },\n                    '*': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n                        cardinality: 1\n                    }\n                },\n                keyCode: {\n                    ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,\n                    NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91\n                },\n                //specify keycodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\n                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],\n                isComplete: undefined //override for isComplete - args => buffer, opts - return true || false\n            },\n            masksCache: {},\n            escapeRegex: function (str) {\n                var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n                return str.replace(new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'gim'), '\\\\$1');\n            },\n            format: function (value, options) {\n                var opts = $.extend(true, {}, $.inputmask.defaults, options);\n                resolveAlias(opts.alias, options, opts);\n                return maskScope({ \"action\": \"format\", \"value\": value }, generateMaskSet(opts), opts);\n            },\n            isValid: function (value, options) {\n                var opts = $.extend(true, {}, $.inputmask.defaults, options);\n                resolveAlias(opts.alias, options, opts);\n                return maskScope({ \"action\": \"isValid\", \"value\": value }, generateMaskSet(opts), opts);\n            }\n        };\n\n        $.fn.inputmask = function (fn, options, targetScope, targetData, msk) {\n            targetScope = targetScope || maskScope;\n            targetData = targetData || \"_inputmask\";\n            function importAttributeOptions(npt, opts) {\n                var $npt = $(npt);\n                for (var option in opts) {\n                    var optionData = $npt.data(\"inputmask-\" + option.toLowerCase());\n                    if (optionData != undefined)\n                        opts[option] = optionData;\n                }\n                return opts;\n            }\n            var opts = $.extend(true, {}, $.inputmask.defaults, options),\n                maskset;\n\n            if (typeof fn === \"string\") {\n                switch (fn) {\n                    case \"mask\":\n                        //resolve possible aliases given by options\n                        resolveAlias(opts.alias, options, opts);\n                        maskset = generateMaskSet(opts);\n                        if (maskset.length == 0) { return this; }\n\n                        return this.each(function () {\n                            targetScope({ \"action\": \"mask\", \"el\": this }, $.extend(true, {}, $.isArray(maskset) && targetScope === maskScope ? maskset[0] : maskset), importAttributeOptions(this, opts));\n                        });\n                    case \"unmaskedvalue\":\n                        var $input = $(this);\n                        if ($input.data(targetData)) {\n                            return targetScope({ \"action\": \"unmaskedvalue\", \"$input\": $input });\n                        } else return $input.val();\n                    case \"remove\":\n                        return this.each(function () {\n                            var $input = $(this);\n                            if ($input.data(targetData)) {\n                                targetScope({ \"action\": \"remove\", \"el\": this });\n                            }\n                        });\n                    case \"getemptymask\": //return the default (empty) mask value, usefull for setting the default value in validation\n                        if (this.data(targetData)) {\n                            return targetScope({ \"action\": \"getemptymask\", \"el\": this });\n                        }\n                        else return \"\";\n                    case \"hasMaskedValue\": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value \n                        return this.data(targetData) ? !this.data(targetData)['opts'].autoUnmask : false;\n                    case \"isComplete\":\n                        if (this.data(targetData)) {\n                            return targetScope({ \"action\": \"isComplete\", \"buffer\": this[0]._valueGet().split(''), \"el\": this });\n                        } else return true;\n                    case \"getmetadata\": //return mask metadata if exists\n                        if (this.data(targetData)) {\n                            maskset = this.data(targetData)['maskset'];\n                            return maskset['metadata'];\n                        }\n                        else return undefined;\n                    case \"_detectScope\":\n                        resolveAlias(opts.alias, options, opts);\n                        if (msk != undefined && !resolveAlias(msk, options, opts) && $.inArray(msk, [\"mask\", \"unmaskedvalue\", \"remove\", \"getemptymask\", \"hasMaskedValue\", \"isComplete\", \"getmetadata\", \"_detectScope\"]) == -1) {\n                            opts.mask = msk;\n                        }\n                        if ($.isFunction(opts.mask)) {\n                            opts.mask = opts.mask.call(this, opts);\n                        }\n                        return $.isArray(opts.mask);\n                    default:\n                        resolveAlias(opts.alias, options, opts);\n                        //check if the fn is an alias\n                        if (!resolveAlias(fn, options, opts)) {\n                            //maybe fn is a mask so we try\n                            //set mask\n                            opts.mask = fn;\n                        }\n                        maskset = generateMaskSet(opts);\n                        if (maskset == undefined) { return this; }\n                        return this.each(function () {\n                            targetScope({ \"action\": \"mask\", \"el\": this }, $.extend(true, {}, $.isArray(maskset) && targetScope === maskScope ? maskset[0] : maskset), importAttributeOptions(this, opts));\n                        });\n                }\n            } else if (typeof fn == \"object\") {\n                opts = $.extend(true, {}, $.inputmask.defaults, fn);\n\n                resolveAlias(opts.alias, fn, opts); //resolve aliases\n                maskset = generateMaskSet(opts);\n                if (maskset == undefined) { return this; }\n                return this.each(function () {\n                    targetScope({ \"action\": \"mask\", \"el\": this }, $.extend(true, {}, $.isArray(maskset) && targetScope === maskScope ? maskset[0] : maskset), importAttributeOptions(this, opts));\n                });\n            } else if (fn == undefined) {\n                //look for data-inputmask atribute - the attribute should only contain optipns\n                return this.each(function () {\n                    var attrOptions = $(this).attr(\"data-inputmask\");\n                    if (attrOptions && attrOptions != \"\") {\n                        try {\n                            attrOptions = attrOptions.replace(new RegExp(\"'\", \"g\"), '\"');\n                            var dataoptions = $.parseJSON(\"{\" + attrOptions + \"}\");\n                            $.extend(true, dataoptions, options);\n                            opts = $.extend(true, {}, $.inputmask.defaults, dataoptions);\n                            resolveAlias(opts.alias, dataoptions, opts);\n                            opts.alias = undefined;\n                            $(this).inputmask(\"mask\", opts, targetScope);\n                        } catch (ex) { } //need a more relax parseJSON\n                    }\n                });\n            }\n        };\n    }\n})(jQuery);\n/**\n* @license Input Mask plugin for jquery\n* http://github.com/RobinHerbots/jquery.inputmask\n* Copyright (c) 2010 - 2014 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 3.0.56\n*/\n\n(function ($) {\n    if ($.fn.inputmask != undefined) {\n        function multiMaskScope(actionObj, masksets, opts) {\n            function isInputEventSupported(eventName) {\n                var el = document.createElement('input'),\n                    eventName = 'on' + eventName,\n                    isSupported = (eventName in el);\n                if (!isSupported) {\n                    el.setAttribute(eventName, 'return;');\n                    isSupported = typeof el[eventName] == 'function';\n                }\n                el = null;\n                return isSupported;\n            }\n            var PasteEventType = isInputEventSupported('paste') ? 'paste' : isInputEventSupported('input') ? 'input' : \"propertychange\",\n                isRTL, el, $el, elmasks, activeMasksetIndex;\n\n            function PatchValhookMulti(type) {\n                if ($.valHooks[type] == undefined || $.valHooks[type].inputmaskmultipatch != true) {\n                    var valueGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) { return elem.value; };\n                    var valueSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\n                        elem.value = value;\n                        return elem;\n                    };\n\n                    $.valHooks[type] = {\n                        get: function (elem) {\n                            var $elem = $(elem);\n                            if ($elem.data('_inputmask-multi')) {\n                                var data = $elem.data('_inputmask-multi');\n                                return valueGet(data[\"elmasks\"][data[\"activeMasksetIndex\"]]);\n                            } else return valueGet(elem);\n                        },\n                        set: function (elem, value) {\n                            var $elem = $(elem);\n                            var result = valueSet(elem, value);\n                            if ($elem.data('_inputmask-multi')) $elem.triggerHandler('setvalue');\n                            return result;\n                        },\n                        inputmaskmultipatch: true\n                    };\n                }\n            }\n\n            function mcaret(input, begin, end) {\n                var npt = input.jquery && input.length > 0 ? input[0] : input, range;\n                if (typeof begin == 'number') {\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    end = (typeof end == 'number') ? end : begin;\n\n                    //store caret for multi scope\n                    if (npt != el) {\n                        var data = $(npt).data('_inputmask') || {};\n                        data[\"caret\"] = { \"begin\": begin, \"end\": end };\n                        $(npt).data('_inputmask', data);\n                    }\n                    if (!$(npt).is(\":visible\")) {\n                        return;\n                    }\n\n                    npt.scrollLeft = npt.scrollWidth;\n                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode\n                    if (npt.setSelectionRange) {\n                        npt.selectionStart = begin;\n                        npt.selectionEnd = end;\n\n                    } else if (npt.createTextRange) {\n                        range = npt.createTextRange();\n                        range.collapse(true);\n                        range.moveEnd('character', end);\n                        range.moveStart('character', begin);\n                        range.select();\n                    }\n                } else {\n                    var data = $(npt).data('_inputmask');\n                    if (!$(npt).is(\":visible\") && data && data[\"caret\"] != undefined) {\n                        begin = data[\"caret\"][\"begin\"];\n                        end = data[\"caret\"][\"end\"];\n                    } else if (npt.setSelectionRange) {\n                        begin = npt.selectionStart;\n                        end = npt.selectionEnd;\n                    } else if (document.selection && document.selection.createRange) {\n                        range = document.selection.createRange();\n                        begin = 0 - range.duplicate().moveStart('character', -100000);\n                        end = begin + range.text.length;\n                    }\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    return { \"begin\": begin, \"end\": end };\n                }\n            }\n\n            function TranslatePosition(pos) {\n                if (isRTL && typeof pos == 'number' && (!opts.greedy || opts.placeholder != \"\")) {\n                    var bffrLght = el.value.length;\n                    pos = bffrLght - pos;\n                }\n                return pos;\n            }\n\n            function determineActiveMask(eventType, elmasks) {\n\n                if (eventType != \"multiMaskScope\") {\n                    if ($.isFunction(opts.determineActiveMasksetIndex))\n                        activeMasksetIndex = opts.determineActiveMasksetIndex.call($el, eventType, elmasks);\n                    else {\n                        var lpc = -1, cp = -1, lvp = -1;;\n                        $.each(elmasks, function (ndx, lmsk) {\n                            var data = $(lmsk).data('_inputmask');\n                            var maskset = data[\"maskset\"];\n                            var lastValidPosition = -1, validPositionCount = 0, caretPos = mcaret(lmsk).begin;\n                            for (var posNdx in maskset[\"validPositions\"]) {\n                                var psNdx = parseInt(posNdx);\n                                if (psNdx > lastValidPosition) lastValidPosition = psNdx;\n                                validPositionCount++;\n                            }\n                            if (validPositionCount > lpc\n                                    || (validPositionCount == lpc && cp > caretPos && lvp > lastValidPosition)\n                                    || (validPositionCount == lpc && cp == caretPos && lvp < lastValidPosition)\n                            ) {\n                                //console.log(\"lvp \" + lastValidPosition + \" vpc \" + validPositionCount + \" caret \" + caretPos + \" ams \" + ndx);\n                                lpc = validPositionCount;\n                                cp = caretPos;\n                                activeMasksetIndex = ndx;\n                                lvp = lastValidPosition;\n                            }\n                        });\n                    }\n\n                    var data = $el.data('_inputmask-multi') || { \"activeMasksetIndex\": 0, \"elmasks\": elmasks };\n                    data[\"activeMasksetIndex\"] = activeMasksetIndex;\n                    $el.data('_inputmask-multi', data);\n                }\n\n                if ($.inArray(eventType, [\"focus\"]) == -1 && el.value != elmasks[activeMasksetIndex]._valueGet()) {\n                    var value = $(elmasks[activeMasksetIndex]).val() == \"\" ? elmasks[activeMasksetIndex]._valueGet() : $(elmasks[activeMasksetIndex]).val();\n                    el.value = value;\n                }\n                if ($.inArray(eventType, [\"blur\", \"focus\"]) == -1) {\n                    if ($(elmasks[activeMasksetIndex]).hasClass(\"focus-inputmask\")) {\n                        var activeCaret = mcaret(elmasks[activeMasksetIndex]);\n                        mcaret(el, activeCaret.begin, activeCaret.end);\n                    }\n                }\n            }\n\n            opts.multi = true;\n\n            function mask(npt) {\n                el = npt;\n                $el = $(el);\n                isRTL = el.dir == \"rtl\" || opts.numericInput;\n                activeMasksetIndex = 0;\n                elmasks = $.map(masksets, function (msk, ndx) {\n                    var elMaskStr = '<input type=\"text\" ';\n                    if ($el.attr(\"value\")) elMaskStr += 'value=\"' + $el.attr(\"value\") + '\" ';\n                    if ($el.attr(\"dir\")) elMaskStr += 'dir=\"' + $el.attr(\"dir\") + '\" ';\n                    elMaskStr += '/>';\n                    var elmask = $(elMaskStr)[0];\n                    $(elmask).inputmask($.extend({}, opts, { mask: msk.mask }));\n                    return elmask;\n                });\n\n                $el.data('_inputmask-multi', { \"activeMasksetIndex\": 0, \"elmasks\": elmasks });\n                if (el.dir == \"rtl\" || opts.rightAlign)\n                    $el.css(\"text-align\", \"right\");\n                el.dir = \"ltr\";\n                $el.removeAttr(\"dir\");\n                if ($el.attr(\"value\") != \"\") {\n                    determineActiveMask(\"init\", elmasks);\n                }\n\n                $el.bind(\"mouseenter blur focus mouseleave click dblclick keydown keypress keypress\", function (e) {\n                    var caretPos = mcaret(el), k, goDetermine = true;\n                    if (e.type == \"keydown\") {\n                        k = e.keyCode;\n                        if (k == opts.keyCode.DOWN && activeMasksetIndex < elmasks.length - 1) {\n                            activeMasksetIndex++;\n                            determineActiveMask(\"multiMaskScope\", elmasks);\n                            return false;\n                        } else if (k == opts.keyCode.UP && activeMasksetIndex > 0) {\n                            activeMasksetIndex--;\n                            determineActiveMask(\"multiMaskScope\", elmasks);\n                            return false;\n                        }\n                        if (e.ctrlKey || e.shiftKey || e.altKey) {\n                            return true;\n                        }\n                    } else if (e.type == \"keypress\" && (e.ctrlKey || e.shiftKey || e.altKey)) {\n                        return true;\n                    }\n                    $.each(elmasks, function (ndx, lmnt) {\n                        if (e.type == \"keydown\") {\n                            k = e.keyCode;\n\n                            if (k == opts.keyCode.BACKSPACE && lmnt._valueGet().length < caretPos.begin) {\n                                return;\n                            } else if (k == opts.keyCode.TAB) {\n                                goDetermine = false;\n                            } else if (k == opts.keyCode.RIGHT) {\n                                mcaret(lmnt, caretPos.begin + 1, caretPos.end + 1);\n                                goDetermine = false;\n                                return;\n                            } else if (k == opts.keyCode.LEFT) {\n                                mcaret(lmnt, caretPos.begin - 1, caretPos.end - 1);\n                                goDetermine = false;\n                                return;\n                            }\n                        }\n                        if ($.inArray(e.type, [\"click\"]) != -1) {\n                            mcaret(lmnt, TranslatePosition(caretPos.begin), TranslatePosition(caretPos.end));\n                            if (caretPos.begin != caretPos.end) {\n                                goDetermine = false;\n                                return;\n                            }\n                        }\n\n                        if ($.inArray(e.type, [\"keydown\"]) != -1 && caretPos.begin != caretPos.end) {\n                            mcaret(lmnt, caretPos.begin, caretPos.end);\n                        }\n\n                        $(lmnt).triggerHandler(e);\n                    });\n                    if (goDetermine) {\n                        setTimeout(function () {\n                            determineActiveMask(e.type, elmasks);\n                        }, 0);\n                    }\n                });\n                $el.bind(PasteEventType + \" dragdrop drop setvalue\", function (e) {\n                    var caretPos = mcaret(el);\n                    setTimeout(function () {\n                        $.each(elmasks, function (ndx, lmnt) {\n                            lmnt._valueSet(el.value);\n                            $(lmnt).triggerHandler(e);\n                        });\n                        setTimeout(function () {\n                            determineActiveMask(e.type, elmasks);\n                        }, 0);\n                    }, 0);\n                });\n                PatchValhookMulti(el.type);\n            }\n\n            //action object\n            if (actionObj != undefined) {\n                switch (actionObj[\"action\"]) {\n                    case \"isComplete\":\n                        $el = $(actionObj[\"el\"]);\n                        var imdata = $el.data('_inputmask-multi'),\n                            activeMask = imdata[\"elmasks\"][imdata[\"activeMasksetIndex\"]];\n                        return $(activeMask).inputmask(\"isComplete\");\n                    case \"unmaskedvalue\":\n                        $el = actionObj[\"$input\"];\n                        var imdata = $el.data('_inputmask-multi'),\n                            activeMask = imdata[\"elmasks\"][imdata[\"activeMasksetIndex\"]];\n                        return $(activeMask).inputmask(\"unmaskedvalue\");\n                    case \"mask\":\n                        mask(actionObj[\"el\"]);\n                        break;\n                    case \"format\": //TODO\n                        $el = $({});\n                        $el.data('_inputmask', {\n                            'maskset': maskset,\n                            'opts': opts,\n                            'isRTL': opts.numericInput\n                        });\n                        if (opts.numericInput) {\n                            isRTL = true;\n                        }\n                        var valueBuffer = actionObj[\"value\"].split('');\n                        checkVal($el, false, false, isRTL ? valueBuffer.reverse() : valueBuffer, true);\n                        return isRTL ? getBuffer().reverse().join('') : getBuffer().join('');\n                    case \"isValid\": //TODO\n                        $el = $({});\n                        $el.data('_inputmask', {\n                            'maskset': maskset,\n                            'opts': opts,\n                            'isRTL': opts.numericInput\n                        });\n                        if (opts.numericInput) {\n                            isRTL = true;\n                        }\n                        var valueBuffer = actionObj[\"value\"].split('');\n                        checkVal($el, false, true, isRTL ? valueBuffer.reverse() : valueBuffer);\n                        return isComplete(getBuffer());\n                    case \"getemptymask\": //TODO\n                        $el = $(actionObj[\"el\"]);\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        return getBufferTemplate();\n                    case \"remove\": //TODO\n                        var el = actionObj[\"el\"];\n                        $el = $(el);\n                        maskset = $el.data('_inputmask')['maskset'];\n                        opts = $el.data('_inputmask')['opts'];\n                        //writeout the unmaskedvalue\n                        el._valueSet(unmaskedvalue($el));\n                        //unbind all events\n                        $el.unbind(\".inputmask\");\n                        $el.removeClass('focus-inputmask');\n                        //clear data\n                        $el.removeData('_inputmask');\n                        //restore the value property\n                        var valueProperty;\n                        if (Object.getOwnPropertyDescriptor)\n                            valueProperty = Object.getOwnPropertyDescriptor(el, \"value\");\n                        if (valueProperty && valueProperty.get) {\n                            if (el._valueGet) {\n                                Object.defineProperty(el, \"value\", {\n                                    get: el._valueGet,\n                                    set: el._valueSet\n                                });\n                            }\n                        } else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\n                            if (el._valueGet) {\n                                el.__defineGetter__(\"value\", el._valueGet);\n                                el.__defineSetter__(\"value\", el._valueSet);\n                            }\n                        }\n                        try { //try catch needed for IE7 as it does not supports deleting fns\n                            delete el._valueGet;\n                            delete el._valueSet;\n                        } catch (e) {\n                            el._valueGet = undefined;\n                            el._valueSet = undefined;\n\n                        }\n                        break;\n                }\n            }\n        };\n\n        $.extend($.inputmask.defaults, {\n            //multi-masks\n            multi: false, //do not alter - internal use\n            determineActiveMasksetIndex: undefined //override determineActiveMasksetIndex - args => eventType, elmasks - return int\n        });\n\n        $.inputmask._fn = $.fn.inputmask;\n        $.fn.inputmask = function (fn, options) {\n            if (typeof fn === \"string\") {\n                if ($.inputmask._fn(\"_detectScope\", options, undefined, undefined, fn))\n                    return $.inputmask._fn.call(this, fn, options, multiMaskScope, \"_inputmask-multi\");\n                else return $.inputmask._fn.call(this, fn, options);\n            } else if (typeof fn == \"object\") {\n                if ($.inputmask._fn(\"_detectScope\", fn))\n                    return $.inputmask._fn.call(this, fn, options, multiMaskScope, \"_inputmask-multi\");\n                else return $.inputmask._fn.call(this, fn, options);\n            } else if (fn == undefined)\n                return $.inputmask._fn.call(this, fn, options);\n        };\n    }\n})(jQuery);\n/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 3.0.56\n\nOptional extensions on the jquery.inputmask base\n*/\n(function ($) {\n    //extra definitions\n    $.extend($.inputmask.defaults.definitions, {\n        'A': {\n            validator: \"[A-Za-z]\",\n            cardinality: 1,\n            casing: \"upper\" //auto uppercasing\n        },\n        '#': {\n            validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n            cardinality: 1,\n            casing: \"upper\"\n        }\n    });\n    $.extend($.inputmask.defaults.aliases, {\n        'url': {\n            mask: \"ir\",\n            placeholder: \"\",\n            separator: \"\",\n            defaultPrefix: \"http://\",\n            regex: {\n                urlpre1: new RegExp(\"[fh]\"),\n                urlpre2: new RegExp(\"(ft|ht)\"),\n                urlpre3: new RegExp(\"(ftp|htt)\"),\n                urlpre4: new RegExp(\"(ftp:|http|ftps)\"),\n                urlpre5: new RegExp(\"(ftp:/|ftps:|http:|https)\"),\n                urlpre6: new RegExp(\"(ftp://|ftps:/|http:/|https:)\"),\n                urlpre7: new RegExp(\"(ftp://|ftps://|http://|https:/)\"),\n                urlpre8: new RegExp(\"(ftp://|ftps://|http://|https://)\")\n            },\n            definitions: {\n                'i': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        return true;\n                    },\n                    cardinality: 8,\n                    prevalidator: (function () {\n                        var result = [], prefixLimit = 8;\n                        for (var i = 0; i < prefixLimit; i++) {\n                            result[i] = (function () {\n                                var j = i;\n                                return {\n                                    validator: function (chrs, maskset, pos, strict, opts) {\n                                        if (opts.regex[\"urlpre\" + (j + 1)]) {\n                                            var tmp = chrs, k;\n                                            if (((j + 1) - chrs.length) > 0) {\n                                                tmp = maskset.buffer.join('').substring(0, ((j + 1) - chrs.length)) + \"\" + tmp;\n                                            }\n                                            var isValid = opts.regex[\"urlpre\" + (j + 1)].test(tmp);\n                                            if (!strict && !isValid) {\n                                                pos = pos - j;\n                                                for (k = 0; k < opts.defaultPrefix.length; k++) {\n                                                    maskset.buffer[pos] = opts.defaultPrefix[k]; pos++;\n                                                }\n                                                for (k = 0; k < tmp.length - 1; k++) {\n                                                    maskset.buffer[pos] = tmp[k]; pos++;\n                                                }\n                                                return { \"pos\": pos };\n                                            }\n                                            return isValid;\n                                        } else {\n                                            return false;\n                                        }\n                                    }, cardinality: j\n                                };\n                            })();\n                        }\n                        return result;\n                    })()\n                },\n                \"r\": {\n                    validator: \".\",\n                    cardinality: 50\n                }\n            },\n            insertMode: false,\n            autoUnmask: false\n        },\n        \"ip\": { //ip-address mask\n            mask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\n            definitions: {\n                'i': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        if (pos - 1 > -1 && maskset.buffer[pos - 1] != \".\") {\n                            chrs = maskset.buffer[pos - 1] + chrs;\n                            if (pos - 2 > -1 && maskset.buffer[pos - 2] != \".\") {\n                                chrs = maskset.buffer[pos - 2] + chrs;\n                            } else chrs = \"0\" + chrs;\n                        } else chrs = \"00\" + chrs;\n                        return new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\n                    },\n                    cardinality: 1\n                }\n            }\n        },\n        \"email\": {\n            mask: \"*{1,20}[.*{1,20}][.*{1,20}][.*{1,20}]@*{1,20}.*{2,6}[.*{1,2}]\",\n            greedy: false,\n            onBeforePaste: function (pastedValue, opts) {\n                pastedValue = pastedValue.toLowerCase();\n                return pastedValue.replace(\"mailto:\", \"\");\n            },\n            definitions: {\n                '*': {\n                    validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n                    cardinality: 1,\n                    casing: \"lower\"\n                }\n            }\n        }\n    });\n})(jQuery);\n/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 3.0.56\n\nOptional extensions on the jquery.inputmask base\n*/\n(function ($) {\n    //date & time aliases\n    $.extend($.inputmask.defaults.definitions, {\n        'h': { //hours\n            validator: \"[01][0-9]|2[0-3]\",\n            cardinality: 2,\n            prevalidator: [{ validator: \"[0-2]\", cardinality: 1 }]\n        },\n        's': { //seconds || minutes\n            validator: \"[0-5][0-9]\",\n            cardinality: 2,\n            prevalidator: [{ validator: \"[0-5]\", cardinality: 1 }]\n        },\n        'd': { //basic day\n            validator: \"0[1-9]|[12][0-9]|3[01]\",\n            cardinality: 2,\n            prevalidator: [{ validator: \"[0-3]\", cardinality: 1 }]\n        },\n        'm': { //basic month\n            validator: \"0[1-9]|1[012]\",\n            cardinality: 2,\n            prevalidator: [{ validator: \"[01]\", cardinality: 1 }]\n        },\n        'y': { //basic year\n            validator: \"(19|20)\\\\d{2}\",\n            cardinality: 4,\n            prevalidator: [\n                        { validator: \"[12]\", cardinality: 1 },\n                        { validator: \"(19|20)\", cardinality: 2 },\n                        { validator: \"(19|20)\\\\d\", cardinality: 3 }\n            ]\n        }\n    });\n    $.extend($.inputmask.defaults.aliases, {\n        'dd/mm/yyyy': {\n            mask: \"1/2/y\",\n            placeholder: \"dd/mm/yyyy\",\n            regex: {\n                val1pre: new RegExp(\"[0-3]\"), //daypre\n                val1: new RegExp(\"0[1-9]|[12][0-9]|3[01]\"), //day\n                val2pre: function (separator) { var escapedSeparator = $.inputmask.escapeRegex.call(this, separator); return new RegExp(\"((0[1-9]|[12][0-9]|3[01])\" + escapedSeparator + \"[01])\"); }, //monthpre\n                val2: function (separator) { var escapedSeparator = $.inputmask.escapeRegex.call(this, separator); return new RegExp(\"((0[1-9]|[12][0-9])\" + escapedSeparator + \"(0[1-9]|1[012]))|(30\" + escapedSeparator + \"(0[13-9]|1[012]))|(31\" + escapedSeparator + \"(0[13578]|1[02]))\"); }//month\n            },\n            leapday: \"29/02/\",\n            separator: '/',\n            yearrange: { minyear: 1900, maxyear: 2099 },\n            isInYearRange: function (chrs, minyear, maxyear) {\n                if (isNaN(chrs)) return false;\n                var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length)));\n                var enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));\n                return (!isNaN(enteredyear) ? minyear <= enteredyear && enteredyear <= maxyear : false) ||\n            \t\t   (!isNaN(enteredyear2) ? minyear <= enteredyear2 && enteredyear2 <= maxyear : false);\n            },\n            determinebaseyear: function (minyear, maxyear, hint) {\n                var currentyear = (new Date()).getFullYear();\n                if (minyear > currentyear) return minyear;\n                if (maxyear < currentyear) {\n                    var maxYearPrefix = maxyear.toString().slice(0, 2);\n                    var maxYearPostfix = maxyear.toString().slice(2, 4);\n                    while (maxyear < maxYearPrefix + hint) {\n                        maxYearPrefix--;\n                    }\n                    var maxxYear = maxYearPrefix + maxYearPostfix;\n                    return minyear > maxxYear ? minyear : maxxYear;\n                }\n\n                return currentyear;\n            },\n            onKeyUp: function (e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode == opts.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString());\n                }\n            },\n            definitions: {\n                '1': { //val1 ~ day or month\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.regex.val1.test(chrs);\n                        if (!strict && !isValid) {\n                            if (chrs.charAt(1) == opts.separator || \"-./\".indexOf(chrs.charAt(1)) != -1) {\n                                isValid = opts.regex.val1.test(\"0\" + chrs.charAt(0));\n                                if (isValid) {\n                                    maskset.buffer[pos - 1] = \"0\";\n                                    return { \"refreshFromBuffer\": { start: pos - 1, end: pos }, \"pos\": pos, \"c\": chrs.charAt(0) };\n                                }\n                            }\n                        }\n                        return isValid;\n                    },\n                    cardinality: 2,\n                    prevalidator: [{\n                        validator: function (chrs, maskset, pos, strict, opts) {\n                            if (!isNaN(maskset.buffer[pos + 1])) chrs += maskset.buffer[pos + 1];\n                            var isValid = chrs.length == 1 ? opts.regex.val1pre.test(chrs) : opts.regex.val1.test(chrs);\n                            if (!strict && !isValid) {\n                                isValid = opts.regex.val1.test(\"0\" + chrs);\n                                if (isValid) {\n                                    maskset.buffer[pos] = \"0\";\n                                    pos++;\n                                    return { \"pos\": pos };\n                                }\n                            }\n                            return isValid;\n                        }, cardinality: 1\n                    }]\n                },\n                '2': { //val2 ~ day or month\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var frontValue = (opts.mask.indexOf(\"2\") == opts.mask.length - 1) ? maskset.buffer.join('').substr(5, 3) : maskset.buffer.join('').substr(0, 3);\n                        if (frontValue.indexOf(opts.placeholder[0]) != -1) frontValue = \"01\" + opts.separator;\n                        var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);\n                        if (!strict && !isValid) {\n                            if (chrs.charAt(1) == opts.separator || \"-./\".indexOf(chrs.charAt(1)) != -1) {\n                                isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs.charAt(0));\n                                if (isValid) {\n                                    maskset.buffer[pos - 1] = \"0\";\n                                    return { \"refreshFromBuffer\": { start: pos - 1, end: pos }, \"pos\": pos, \"c\": chrs.charAt(0) };\n                                }\n                            }\n                        }\n\n                        //check leap yeap\n                        if ((opts.mask.indexOf(\"2\") == opts.mask.length - 1) && isValid) {\n                            var dayMonthValue = maskset.buffer.join('').substr(4, 4) + chrs;\n                            if (dayMonthValue != opts.leapday)\n                                return true;\n                            else {\n                                var year = parseInt(maskset.buffer.join('').substr(0, 4), 10);  //detect leap year\n                                if (year % 4 === 0)\n                                    if (year % 100 === 0)\n                                        if (year % 400 === 0)\n                                            return true;\n                                        else return false;\n                                    else return true;\n                                else return false;\n                            }\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 2,\n                    prevalidator: [{\n                        validator: function (chrs, maskset, pos, strict, opts) {\n                            if (!isNaN(maskset.buffer[pos + 1])) chrs += maskset.buffer[pos + 1];\n                            var frontValue = (opts.mask.indexOf(\"2\") == opts.mask.length - 1) ? maskset.buffer.join('').substr(5, 3) : maskset.buffer.join('').substr(0, 3);\n                            if (frontValue.indexOf(opts.placeholder[0]) != -1) frontValue = \"01\" + opts.separator;\n                            var isValid = chrs.length == 1 ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);\n                            if (!strict && !isValid) {\n                                isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs);\n                                if (isValid) {\n                                    maskset.buffer[pos] = \"0\";\n                                    pos++;\n                                    return { \"pos\": pos };\n                                }\n                            }\n                            return isValid;\n                        }, cardinality: 1\n                    }]\n                },\n                'y': { //year\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        if (opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) {\n                            var dayMonthValue = maskset.buffer.join('').substr(0, 6);\n                            if (dayMonthValue != opts.leapday)\n                                return true;\n                            else {\n                                var year = parseInt(chrs, 10);//detect leap year\n                                if (year % 4 === 0)\n                                    if (year % 100 === 0)\n                                        if (year % 400 === 0)\n                                            return true;\n                                        else return false;\n                                    else return true;\n                                else return false;\n                            }\n                        } else return false;\n                    },\n                    cardinality: 4,\n                    prevalidator: [\n                {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                        if (!strict && !isValid) {\n                            var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 1);\n\n                            isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                            if (isValid) {\n                                maskset.buffer[pos++] = yearPrefix[0];\n                                return { \"pos\": pos };\n                            }\n                            yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 2);\n\n                            isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                            if (isValid) {\n                                maskset.buffer[pos++] = yearPrefix[0];\n                                maskset.buffer[pos++] = yearPrefix[1];\n                                return { \"pos\": pos };\n                            }\n                        }\n                        return isValid;\n                    },\n                    cardinality: 1\n                },\n                {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                        if (!strict && !isValid) {\n                            var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);\n\n                            isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear);\n                            if (isValid) {\n                                maskset.buffer[pos++] = yearPrefix[1];\n                                return { \"pos\": pos };\n                            }\n\n                            yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);\n                            if (opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) {\n                                var dayMonthValue = maskset.buffer.join('').substr(0, 6);\n                                if (dayMonthValue != opts.leapday)\n                                    isValid = true;\n                                else {\n                                    var year = parseInt(chrs, 10);//detect leap year\n                                    if (year % 4 === 0)\n                                        if (year % 100 === 0)\n                                            if (year % 400 === 0)\n                                                isValid = true;\n                                            else isValid = false;\n                                        else isValid = true;\n                                    else isValid = false;\n                                }\n                            } else isValid = false;\n                            if (isValid) {\n                                maskset.buffer[pos - 1] = yearPrefix[0];\n                                maskset.buffer[pos++] = yearPrefix[1];\n                                maskset.buffer[pos++] = chrs[0];\n                                return { \"refreshFromBuffer\": { start: pos - 3, end: pos }, \"pos\": pos };\n                            }\n                        }\n                        return isValid;\n                    }, cardinality: 2\n                },\n                {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\n                    }, cardinality: 3\n                }\n                    ]\n                }\n            },\n            insertMode: false,\n            autoUnmask: false\n        },\n        'mm/dd/yyyy': {\n            placeholder: \"mm/dd/yyyy\",\n            alias: \"dd/mm/yyyy\", //reuse functionality of dd/mm/yyyy alias\n            regex: {\n                val2pre: function (separator) { var escapedSeparator = $.inputmask.escapeRegex.call(this, separator); return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\"); }, //daypre\n                val2: function (separator) { var escapedSeparator = $.inputmask.escapeRegex.call(this, separator); return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\"); }, //day\n                val1pre: new RegExp(\"[01]\"), //monthpre\n                val1: new RegExp(\"0[1-9]|1[012]\") //month\n            },\n            leapday: \"02/29/\",\n            onKeyUp: function (e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode == opts.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString());\n                }\n            }\n        },\n        'yyyy/mm/dd': {\n            mask: \"y/1/2\",\n            placeholder: \"yyyy/mm/dd\",\n            alias: \"mm/dd/yyyy\",\n            leapday: \"/02/29\",\n            onKeyUp: function (e, buffer, caretPos, opts) {\n                var $input = $(this);\n                if (e.ctrlKey && e.keyCode == opts.keyCode.RIGHT) {\n                    var today = new Date();\n                    $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString());\n                }\n            }\n        },\n        'dd.mm.yyyy': {\n            mask: \"1.2.y\",\n            placeholder: \"dd.mm.yyyy\",\n            leapday: \"29.02.\",\n            separator: '.',\n            alias: \"dd/mm/yyyy\"\n        },\n        'dd-mm-yyyy': {\n            mask: \"1-2-y\",\n            placeholder: \"dd-mm-yyyy\",\n            leapday: \"29-02-\",\n            separator: '-',\n            alias: \"dd/mm/yyyy\"\n        },\n        'mm.dd.yyyy': {\n            mask: \"1.2.y\",\n            placeholder: \"mm.dd.yyyy\",\n            leapday: \"02.29.\",\n            separator: '.',\n            alias: \"mm/dd/yyyy\"\n        },\n        'mm-dd-yyyy': {\n            mask: \"1-2-y\",\n            placeholder: \"mm-dd-yyyy\",\n            leapday: \"02-29-\",\n            separator: '-',\n            alias: \"mm/dd/yyyy\"\n        },\n        'yyyy.mm.dd': {\n            mask: \"y.1.2\",\n            placeholder: \"yyyy.mm.dd\",\n            leapday: \".02.29\",\n            separator: '.',\n            alias: \"yyyy/mm/dd\"\n        },\n        'yyyy-mm-dd': {\n            mask: \"y-1-2\",\n            placeholder: \"yyyy-mm-dd\",\n            leapday: \"-02-29\",\n            separator: '-',\n            alias: \"yyyy/mm/dd\"\n        },\n        'datetime': {\n            mask: \"1/2/y h:s\",\n            placeholder: \"dd/mm/yyyy hh:mm\",\n            alias: \"dd/mm/yyyy\",\n            regex: {\n                hrspre: new RegExp(\"[012]\"), //hours pre\n                hrs24: new RegExp(\"2[0-4]|1[3-9]\"),\n                hrs: new RegExp(\"[01][0-9]|2[0-4]\"), //hours\n                ampm: new RegExp(\"^[a|p|A|P][m|M]\"),\n                mspre: new RegExp(\"[0-5]\"), //minutes/seconds pre\n                ms: new RegExp(\"[0-5][0-9]\")\n            },\n            timeseparator: ':',\n            hourFormat: \"24\", // or 12\n            definitions: {\n                'h': { //hours\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        if (opts.hourFormat == \"24\") {\n                            if (parseInt(chrs, 10) == 24) {\n                                maskset.buffer[pos - 1] = \"0\";\n                                maskset.buffer[pos] = \"0\";\n                                return { \"refreshFromBuffer\": { start: pos - 1, end: pos }, \"c\": \"0\" };\n                            }\n                        }\n\n                        var isValid = opts.regex.hrs.test(chrs);\n                        if (!strict && !isValid) {\n                            if (chrs.charAt(1) == opts.timeseparator || \"-.:\".indexOf(chrs.charAt(1)) != -1) {\n                                isValid = opts.regex.hrs.test(\"0\" + chrs.charAt(0));\n                                if (isValid) {\n                                    maskset.buffer[pos - 1] = \"0\";\n                                    maskset.buffer[pos] = chrs.charAt(0);\n                                    pos++;\n                                    return { \"refreshFromBuffer\": { start: pos - 2, end: pos }, \"pos\": pos, \"c\": opts.timeseparator };\n                                }\n                            }\n                        }\n\n                        if (isValid && opts.hourFormat !== \"24\" && opts.regex.hrs24.test(chrs)) {\n\n                            var tmp = parseInt(chrs, 10);\n\n                            if (tmp == 24) {\n                                maskset.buffer[pos + 5] = \"a\";\n                                maskset.buffer[pos + 6] = \"m\";\n                            } else {\n                                maskset.buffer[pos + 5] = \"p\";\n                                maskset.buffer[pos + 6] = \"m\";\n                            }\n\n                            tmp = tmp - 12;\n\n                            if (tmp < 10) {\n                                maskset.buffer[pos] = tmp.toString();\n                                maskset.buffer[pos - 1] = \"0\";\n                            } else {\n                                maskset.buffer[pos] = tmp.toString().charAt(1);\n                                maskset.buffer[pos - 1] = tmp.toString().charAt(0);\n                            }\n\n                            return { \"refreshFromBuffer\": { start: pos - 1, end: pos + 6 }, \"c\": maskset.buffer[pos] };\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 2,\n                    prevalidator: [{\n                        validator: function (chrs, maskset, pos, strict, opts) {\n                            var isValid = opts.regex.hrspre.test(chrs);\n                            if (!strict && !isValid) {\n                                isValid = opts.regex.hrs.test(\"0\" + chrs);\n                                if (isValid) {\n                                    maskset.buffer[pos] = \"0\";\n                                    pos++;\n                                    return { \"pos\": pos };\n                                }\n                            }\n                            return isValid;\n                        }, cardinality: 1\n                    }]\n                },\n                's': { //seconds || minutes\n                    validator: \"[0-5][0-9]\",\n                    cardinality: 2,\n                    prevalidator: [\n                        {\n                            validator: function (chrs, maskset, pos, strict, opts) {\n                                var isValid = opts.regex.mspre.test(chrs);\n                                if (!strict && !isValid) {\n                                    isValid = opts.regex.ms.test(\"0\" + chrs);\n                                    if (isValid) {\n                                        maskset.buffer[pos] = \"0\";\n                                        pos++;\n                                        return { \"pos\": pos };\n                                    }\n                                }\n                                return isValid;\n                            }, cardinality: 1\n                        }]\n                },\n                't': { //am/pm\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        return opts.regex.ampm.test(chrs + \"m\");\n                    },\n                    casing: \"lower\",\n                    cardinality: 1\n                }\n            },\n            insertMode: false,\n            autoUnmask: false\n        },\n        'datetime12': {\n            mask: \"1/2/y h:s t\\\\m\",\n            placeholder: \"dd/mm/yyyy hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        'hh:mm t': {\n            mask: \"h:s t\\\\m\",\n            placeholder: \"hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        'h:s t': {\n            mask: \"h:s t\\\\m\",\n            placeholder: \"hh:mm xm\",\n            alias: \"datetime\",\n            hourFormat: \"12\"\n        },\n        'hh:mm:ss': {\n            mask: \"h:s:s\",\n            placeholder: \"hh:mm:ss\",\n            alias: \"datetime\",\n            autoUnmask: false\n        },\n        'hh:mm': {\n            mask: \"h:s\",\n            placeholder: \"hh:mm\",\n            alias: \"datetime\",\n            autoUnmask: false\n        },\n        'date': {\n            alias: \"dd/mm/yyyy\" // \"mm/dd/yyyy\"\n        },\n        'mm/yyyy': {\n            mask: \"1/y\",\n            placeholder: \"mm/yyyy\",\n            leapday: \"donotuse\",\n            separator: '/',\n            alias: \"mm/dd/yyyy\"\n        }\n    });\n})(jQuery);\n/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 3.0.56\n\nOptional extensions on the jquery.inputmask base\n*/\n(function ($) {\n    //number aliases\n    $.extend($.inputmask.defaults.aliases, {\n        'numeric': {\n            mask: function (opts) {\n                if (opts.repeat !== 0 && isNaN(opts.integerDigits)) {\n                    opts.integerDigits = opts.repeat;\n                }\n                opts.repeat = 0;\n\n                opts.autoGroup = opts.autoGroup && opts.groupSeparator != \"\";\n\n                if (opts.autoGroup && isFinite(opts.integerDigits)) {\n                    var seps = Math.floor(opts.integerDigits / opts.groupSize);\n                    var mod = opts.integerDigits % opts.groupSize;\n                    opts.integerDigits += mod == 0 ? seps - 1 : seps;\n                }\n\n                opts.definitions[\":\"].placeholder = opts.radixPoint;\n\n                var mask = opts.prefix;\n                mask += \"[+]\";\n                mask += \"~{1,\" + opts.integerDigits + \"}\";\n                if (opts.digits != undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {\n                    if (opts.digitsOptional)\n                        mask += \"[\" + \":\" + \"~{\" + opts.digits + \"}]\";\n                    else mask += \":\" + \"~{\" + opts.digits + \"}\";\n                }\n                mask += opts.suffix;\n                return mask;\n            },\n            placeholder: \"\",\n            greedy: false,\n            digits: \"*\", //number of fractionalDigits\n            digitsOptional: true,\n            groupSeparator: \"\",//\",\", // | \".\"\n            radixPoint: \".\",\n            groupSize: 3,\n            autoGroup: false,\n            allowPlus: true,\n            allowMinus: true,\n            integerDigits: \"+\", //number of integerDigits\n            prefix: \"\",\n            suffix: \"\",\n            rightAlign: true,\n            postFormat: function (buffer, pos, reformatOnly, opts) {  //this needs to be removed // this is crap\n                var needsRefresh = false, charAtPos = buffer[pos];\n                if (opts.groupSeparator == \"\" ||\n                    ($.inArray(opts.radixPoint, buffer) != -1 && pos >= $.inArray(opts.radixPoint, buffer)) ||\n                    new RegExp('[-\\+]').test(charAtPos)\n                    ) return { pos: pos };\n                var cbuf = buffer.slice();\n                if (charAtPos == opts.groupSeparator) {\n                    cbuf.splice(pos--, 1);\n                    charAtPos = cbuf[pos];\n                }\n                if (reformatOnly) cbuf[pos] = \"?\"; else cbuf.splice(pos, 0, \"?\"); //set position indicator\n                var bufVal = cbuf.join('');\n                if (opts.autoGroup || (reformatOnly && bufVal.indexOf(opts.groupSeparator) != -1)) {\n                    var escapedGroupSeparator = $.inputmask.escapeRegex.call(this, opts.groupSeparator);\n                    needsRefresh = bufVal.indexOf(opts.groupSeparator) == 0;\n                    bufVal = bufVal.replace(new RegExp(escapedGroupSeparator, \"g\"), '');\n                    var radixSplit = bufVal.split(opts.radixPoint);\n                    bufVal = radixSplit[0];\n                    if (bufVal != (opts.prefix + \"?0\") && bufVal.length > (opts.groupSize + opts.prefix.length)) {\n                        needsRefresh = true;\n                        var reg = new RegExp('([-\\+]?[\\\\d\\?]+)([\\\\d\\?]{' + opts.groupSize + '})');\n                        while (reg.test(bufVal)) {\n                            bufVal = bufVal.replace(reg, '$1' + opts.groupSeparator + '$2');\n                            bufVal = bufVal.replace(opts.groupSeparator + opts.groupSeparator, opts.groupSeparator);\n                        }\n                    }\n                    if (radixSplit.length > 1)\n                        bufVal += opts.radixPoint + radixSplit[1];\n                }\n                buffer.length = bufVal.length; //align the length\n                for (var i = 0, l = bufVal.length; i < l; i++) {\n                    buffer[i] = bufVal.charAt(i);\n                }\n                var newPos = $.inArray(\"?\", buffer);\n                if (reformatOnly) buffer[newPos] = charAtPos; else buffer.splice(newPos, 1);\n\n                return { pos: newPos, \"refreshFromBuffer\": needsRefresh };\n            },\n            onKeyDown: function (e, buffer, caretPos, opts) {\n                if (opts.autoGroup && (e.keyCode == opts.keyCode.DELETE || e.keyCode == opts.keyCode.BACKSPACE)) {\n                    var rslt = opts.postFormat(buffer, caretPos - 1, true, opts);\n                    rslt.caret = rslt.pos + 1;\n                    return rslt;\n                }\n            },\n            onKeyPress: function (e, buffer, caretPos, opts) {\n                if (opts.autoGroup /*&& String.fromCharCode(k) == opts.radixPoint*/) {\n                    var rslt = opts.postFormat(buffer, caretPos - 1, true, opts);\n                    rslt.caret = rslt.pos + 1;\n                    return rslt;\n                }\n            },\n            regex: {\n                integerPart: function (opts) { return new RegExp('[-\\+]?\\\\d+'); }\n            },\n            negationhandler: function (chrs, buffer, pos, strict, opts) {\n                if (!strict && opts.allowMinus && chrs === \"-\") {\n                    var matchRslt = buffer.join('').match(opts.regex.integerPart(opts));\n\n                    if (matchRslt.length > 0) {\n                        if (buffer[matchRslt.index] == \"+\") {\n                            return { \"pos\": matchRslt.index, \"c\": \"-\", \"remove\": matchRslt.index, \"caret\": pos };\n                        } else if (buffer[matchRslt.index] == \"-\") {\n                            return { \"remove\": matchRslt.index, \"caret\": pos - 1 };\n                        } else {\n                            return { \"pos\": matchRslt.index, \"c\": \"-\", \"caret\": pos + 1 };\n                        }\n                    }\n                }\n                return false;\n            },\n            definitions: {\n                '~': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.negationhandler(chrs, maskset.buffer, pos, strict, opts);\n                        if (!isValid) {\n                            isValid = strict ? new RegExp(\"[0-9\" + $.inputmask.escapeRegex.call(this, opts.groupSeparator) + \"]\").test(chrs) : new RegExp(\"[0-9]\").test(chrs);\n                            if (isValid === true) isValid = { pos: pos };\n                            if (isValid != false && !strict) {\n                                //handle 0 for integerpart\n                                var matchRslt = maskset.buffer.join('').match(opts.regex.integerPart(opts)), radixPosition = $.inArray(opts.radixPoint, maskset.buffer);\n                                if (matchRslt) {\n                                    if (matchRslt[\"0\"][0].indexOf(\"0\") == 0 && pos >= opts.prefix.length) {\n                                        if (radixPosition == -1 || (pos <= radixPosition && maskset[\"validPositions\"][radixPosition] == undefined)) {\n                                            maskset.buffer.splice(matchRslt.index, 1);\n                                            pos = pos > matchRslt.index ? pos - 1 : matchRslt.index;\n                                            $.extend(isValid, { \"pos\": pos, \"remove\": matchRslt.index });\n                                        } else if (pos > matchRslt.index && pos <= radixPosition) {\n                                            maskset.buffer.splice(matchRslt.index, 1);\n                                            pos = pos > matchRslt.index ? pos - 1 : matchRslt.index;\n                                            $.extend(isValid, { \"pos\": pos, \"remove\": matchRslt.index });\n                                        }\n                                    } else if (chrs == \"0\" && pos <= matchRslt.index) {\n                                        return false;\n                                    }\n                                }\n                                //handle overwrite when fixed precision\n                                if (opts.digitsOptional === false && pos > radixPosition) {\n                                    return { \"pos\": pos, \"remove\": pos };\n                                }\n                            }\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 1,\n                    prevalidator: null\n                },\n                '+': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var signed = \"[\";\n                        if (opts.allowMinus === true) signed += \"-\";\n                        if (opts.allowPlus === true) signed += \"\\+\";\n                        signed += \"]\";\n                        var isValid = new RegExp(signed).test(chrs);\n                        return isValid;\n                    },\n                    cardinality: 1,\n                    prevalidator: null\n                },\n                ':': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        var isValid = opts.negationhandler(chrs, maskset.buffer, pos, strict, opts);\n                        if (!isValid) {\n                            var radix = \"[\" + $.inputmask.escapeRegex.call(this, opts.radixPoint) + \"]\";\n                            isValid = new RegExp(radix).test(chrs);\n                            if (isValid && maskset[\"validPositions\"][pos] && maskset[\"validPositions\"][pos][\"match\"].placeholder == opts.radixPoint) {\n                                isValid = { \"pos\": pos, \"remove\": pos };\n                            }\n                        }\n                        return isValid;\n                    },\n                    cardinality: 1,\n                    prevalidator: null,\n                    placeholder: \"\" //radixpoint will be set in the mask function\n                }\n\n            },\n            insertMode: true,\n            autoUnmask: false,\n            onUnMask: function (maskedValue, unmaskedValue, opts) {\n                var processValue = maskedValue.replace(opts.prefix, \"\");\n                processValue = processValue.replace(opts.suffix, \"\");\n                processValue = processValue.replace(new RegExp($.inputmask.escapeRegex.call(this, opts.groupSeparator), \"g\"), \"\");\n                //processValue = processValue.replace($.inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\n                return processValue;\n            },\n            isComplete: function (buffer, opts) {\n                var maskedValue = buffer.join(''), bufClone = buffer.slice();\n                //verify separator positions\n                opts.postFormat(bufClone, 0, true, opts);\n                if (bufClone.join('') != maskedValue) return false;\n\n                var processValue = maskedValue.replace(opts.prefix, \"\");\n                processValue = processValue.replace(opts.suffix, \"\");\n                processValue = processValue.replace(new RegExp($.inputmask.escapeRegex.call(this, opts.groupSeparator), \"g\"), \"\");\n                processValue = processValue.replace($.inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\n                return isFinite(processValue);\n            },\n            onBeforeMask: function (initialValue, opts) {\n                if (isFinite(initialValue)) {\n                    return initialValue.toString().replace(\".\", opts.radixPoint);\n                } else {\n                    var kommaMatches = initialValue.match(/,/g);\n                    var dotMatches = initialValue.match(/\\./g);\n                    if (dotMatches && kommaMatches) {\n                        if (dotMatches.length > kommaMatches.length) {\n                            initialValue = initialValue.replace(/\\./g, \"\");\n                            initialValue = initialValue.replace(\",\", opts.radixPoint);\n                        } else if (kommaMatches.length > dotMatches.length) {\n                            initialValue = initialValue.replace(/,/g, \"\");\n                            initialValue = initialValue.replace(\".\", opts.radixPoint);\n                        }\n                    } else {\n                        initialValue = initialValue.replace(new RegExp($.inputmask.escapeRegex.call(this, opts.groupSeparator), \"g\"), \"\");\n                    }\n                    return initialValue;\n                }\n            }\n        },\n        'decimal': {\n            alias: \"numeric\"\n        },\n        'integer': {\n            alias: \"numeric\",\n            digits: \"0\"\n        }\n    });\n})(jQuery);\n/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 3.0.56\n\nRegex extensions on the jquery.inputmask base\nAllows for using regular expressions as a mask\n*/\n(function ($) {\n    $.extend($.inputmask.defaults.aliases, { // $(selector).inputmask(\"Regex\", { regex: \"[0-9]*\"}\n        'Regex': {\n            mask: \"r\",\n            greedy: false,\n            repeat: \"*\",\n            regex: null,\n            regexTokens: null,\n            //Thx to https://github.com/slevithan/regex-colorizer for the tokenizer regex\n            tokenizer: /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n            quantifierFilter: /[0-9]+[^,]/,\n            isComplete: function(buffer, opts){\n            \treturn new RegExp(opts.regex).test(buffer.join(''));\n            },\n            definitions: {\n                'r': {\n                    validator: function (chrs, maskset, pos, strict, opts) {\n                        function regexToken(isGroup, isQuantifier) {\n                            this.matches = [];\n                            this.isGroup = isGroup || false;\n                            this.isQuantifier = isQuantifier || false;\n                            this.quantifier = { min: 1, max: 1 };\n                            this.repeaterPart = undefined;\n                        }\n                        function analyseRegex() {\n                            var currentToken = new regexToken(), match, m, opengroups = [];\n\n                            opts.regexTokens = [];\n\n                            // The tokenizer regex does most of the tokenization grunt work\n                            while (match = opts.tokenizer.exec(opts.regex)) {\n                                m = match[0];\n                                switch (m.charAt(0)) {\n                                    case \"(\": // Group opening\n                                        opengroups.push(new regexToken(true));\n                                        break;\n                                    case \")\": // Group closing\n                                        var groupToken = opengroups.pop();\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(groupToken);\n                                        } else {\n                                            currentToken.matches.push(groupToken);\n                                        }\n                                        break;\n                                    case \"{\": case \"+\": case \"*\": //Quantifier\n                                        var quantifierToken = new regexToken(false, true);\n                                        m = m.replace(/[{}]/g, \"\");\n                                        var mq = m.split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = mq.length == 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\n                                        quantifierToken.quantifier = { min: mq0, max: mq1 };\n                                        if (opengroups.length > 0) {\n                                            var matches = opengroups[opengroups.length - 1][\"matches\"];\n                                            match = matches.pop();\n                                            if (!match[\"isGroup\"]) {\n                                                var groupToken = new regexToken(true);\n                                                groupToken.matches.push(match);\n                                                match = groupToken;\n                                            }\n                                            matches.push(match);\n                                            matches.push(quantifierToken);\n                                        } else {\n                                            match = currentToken.matches.pop();\n                                            if (!match[\"isGroup\"]) {\n                                                var groupToken = new regexToken(true);\n                                                groupToken.matches.push(match);\n                                                match = groupToken;\n                                            }\n                                            currentToken.matches.push(match);\n                                            currentToken.matches.push(quantifierToken);\n                                        }\n                                        break;\n                                    default:\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(m);\n                                        } else {\n                                            currentToken.matches.push(m);\n                                        }\n                                        break;\n                                }\n                            }\n\n                            if (currentToken.matches.length > 0)\n                                opts.regexTokens.push(currentToken);\n                        };\n\n                        function validateRegexToken(token, fromGroup) {\n                            var isvalid = false;\n                            if (fromGroup) {\n                                regexPart += \"(\";\n                                openGroupCount++;\n                            }\n                            for (var mndx = 0; mndx < token[\"matches\"].length; mndx++) {\n                                var matchToken = token[\"matches\"][mndx];\n                                if (matchToken[\"isGroup\"] == true) {\n                                    isvalid = validateRegexToken(matchToken, true);\n                                } else if (matchToken[\"isQuantifier\"] == true) {\n                                    var crrntndx = $.inArray(matchToken, token[\"matches\"]),\n                                        matchGroup = token[\"matches\"][crrntndx - 1];\n                                    var regexPartBak = regexPart;\n                                    if (isNaN(matchToken.quantifier.max)) {\n                                        while (matchToken[\"repeaterPart\"] && matchToken[\"repeaterPart\"] != regexPart && matchToken[\"repeaterPart\"].length > regexPart.length) {\n                                            isvalid = validateRegexToken(matchGroup, true);\n                                            if (isvalid) break;\n                                        }\n                                        isvalid = isvalid || validateRegexToken(matchGroup, true);\n                                        if (isvalid) matchToken[\"repeaterPart\"] = regexPart;\n                                        regexPart = regexPartBak + matchToken.quantifier.max;\n                                    } else {\n                                        for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm; i++) {\n                                            isvalid = validateRegexToken(matchGroup, true);\n                                            if (isvalid) break;\n                                        }\n                                        regexPart = regexPartBak + \"{\" + matchToken.quantifier.min + \",\" + matchToken.quantifier.max + \"}\";\n                                    }\n                                } else if (matchToken[\"matches\"] != undefined) {\n                                    for (var k = 0; k < matchToken.length; k++) {\n                                        isvalid = validateRegexToken(matchToken[k], fromGroup);\n                                        if (isvalid) break;\n                                    }\n                                } else {\n                                    var testExp;\n                                    if (matchToken[0] == \"[\") {\n                                        testExp = regexPart;\n                                        testExp += matchToken;\n                                        for (var j = 0; j < openGroupCount; j++) {\n                                            testExp += \")\";\n                                        }\n                                        var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                        isvalid = exp.test(bufferStr);\n                                    } else {\n                                        for (var l = 0, tl = matchToken.length; l < tl; l++) {\n                                            if (matchToken[l] == \"\\\\\") continue;\n                                            testExp = regexPart;\n                                            testExp += matchToken.substr(0, l + 1);\n                                            testExp = testExp.replace(/\\|$/, \"\");\n                                            for (var j = 0; j < openGroupCount; j++) {\n                                                testExp += \")\";\n                                            }\n                                            var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                            isvalid = exp.test(bufferStr);\n                                            if (isvalid) break;\n                                        }\n                                    }\n                                    regexPart += matchToken;\n                                }\n                                if (isvalid) break;\n                            }\n\n                            if (fromGroup) {\n                                regexPart += \")\";\n                                openGroupCount--;\n                            }\n\n                            return isvalid;\n                        }\n\n\n                        if (opts.regexTokens == null) {\n                            analyseRegex();\n                        }\n\n                        var cbuffer = maskset.buffer.slice(), regexPart = \"\", isValid = false, openGroupCount = 0;\n                        cbuffer.splice(pos, 0, chrs);\n                        var bufferStr = cbuffer.join('');\n                        for (var i = 0; i < opts.regexTokens.length; i++) {\n                            var regexToken = opts.regexTokens[i];\n                            isValid = validateRegexToken(regexToken, regexToken[\"isGroup\"]);\n                            if (isValid) break;\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 1\n                }\n            }\n        }\n    });\n})(jQuery);\n/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 3.0.56\n\nPhone extension.\nWhen using this extension make sure you specify the correct url to get the masks\n\n $(selector).inputmask(\"phone\", {\n                url: \"Scripts/jquery.inputmask/phone-codes/phone-codes.json\", \n                onKeyValidation: function () { //show some metadata in the console\n                    console.log($(this).inputmask(\"getmetadata\")[\"name_en\"]);\n                } \n  });\n\n\n*/\n(function ($) {\n    $.extend($.inputmask.defaults.aliases, {\n        'phone': {\n            url: \"phone-codes/phone-codes.json\",\n            mask: function (opts) {\n                opts.definitions = {\n                    'p': {\n                        validator: function () { return false; },\n                        cardinality: 1\n                    },\n                    '#': {\n                        validator: \"[0-9]\",\n                        cardinality: 1\n                    }\n                };\n                var maskList = [];\n                $.ajax({\n                    url: opts.url,\n                    async: false,\n                    dataType: 'json',\n                    success: function (response) {\n                        maskList = response;\n                    }\n                });\n\n                maskList.splice(0, 0, \"+p(ppp)ppp-pppp\");\n                return maskList;\n            },\n            nojumps: true,\n            nojumpsThreshold: 1\n        },\n        'phonebe': {\n            url: \"phone-codes/phone-be.json\",\n            mask: function (opts) {\n                opts.definitions = {\n                    'p': {\n                        validator: function () { return false; },\n                        cardinality: 1\n                    },\n                    '#': {\n                        validator: \"[0-9]\",\n                        cardinality: 1\n                    }\n                };\n                var maskList = [];\n                $.ajax({\n                    url: opts.url,\n                    async: false,\n                    dataType: 'json',\n                    success: function (response) {\n                        maskList = response;\n                    }\n                });\n\n                maskList.splice(0, 0, \"+32(ppp)ppp-pppp\");\n                return maskList;\n            },\n            nojumps: true,\n            nojumpsThreshold: 4\n        }\n    });\n})(jQuery);\n","/*!\nChosen, a Select Box Enhancer for jQuery and Prototype\nby Patrick Filler for Harvest, http://getharvest.com\n\nVersion 1.5.1\nFull source at https://github.com/harvesthq/chosen\nCopyright (c) 2011-2016 Harvest http://getharvest.com\n\nMIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md\nThis file is generated by `grunt build`, do not edit it by hand.\n*/\n\n(function() {\n  var $, AbstractChosen, Chosen, SelectParser, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  SelectParser = (function() {\n    function SelectParser() {\n      this.options_index = 0;\n      this.parsed = [];\n    }\n\n    SelectParser.prototype.add_node = function(child) {\n      if (child.nodeName.toUpperCase() === \"OPTGROUP\") {\n        return this.add_group(child);\n      } else {\n        return this.add_option(child);\n      }\n    };\n\n    SelectParser.prototype.add_group = function(group) {\n      var group_position, option, _i, _len, _ref, _results;\n      group_position = this.parsed.length;\n      this.parsed.push({\n        array_index: group_position,\n        group: true,\n        label: this.escapeExpression(group.label),\n        title: group.title ? group.title : void 0,\n        children: 0,\n        disabled: group.disabled,\n        classes: group.className\n      });\n      _ref = group.childNodes;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        option = _ref[_i];\n        _results.push(this.add_option(option, group_position, group.disabled));\n      }\n      return _results;\n    };\n\n    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {\n      if (option.nodeName.toUpperCase() === \"OPTION\") {\n        if (option.text !== \"\") {\n          if (group_position != null) {\n            this.parsed[group_position].children += 1;\n          }\n          this.parsed.push({\n            array_index: this.parsed.length,\n            options_index: this.options_index,\n            value: option.value,\n            text: option.text,\n            html: option.innerHTML,\n            title: option.title ? option.title : void 0,\n            selected: option.selected,\n            disabled: group_disabled === true ? group_disabled : option.disabled,\n            group_array_index: group_position,\n            group_label: group_position != null ? this.parsed[group_position].label : null,\n            classes: option.className,\n            style: option.style.cssText\n          });\n        } else {\n          this.parsed.push({\n            array_index: this.parsed.length,\n            options_index: this.options_index,\n            empty: true\n          });\n        }\n        return this.options_index += 1;\n      }\n    };\n\n    SelectParser.prototype.escapeExpression = function(text) {\n      var map, unsafe_chars;\n      if ((text == null) || text === false) {\n        return \"\";\n      }\n      if (!/[\\&\\<\\>\\\"\\'\\`]/.test(text)) {\n        return text;\n      }\n      map = {\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#x27;\",\n        \"`\": \"&#x60;\"\n      };\n      unsafe_chars = /&(?!\\w+;)|[\\<\\>\\\"\\'\\`]/g;\n      return text.replace(unsafe_chars, function(chr) {\n        return map[chr] || \"&amp;\";\n      });\n    };\n\n    return SelectParser;\n\n  })();\n\n  SelectParser.select_to_array = function(select) {\n    var child, parser, _i, _len, _ref;\n    parser = new SelectParser();\n    _ref = select.childNodes;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      child = _ref[_i];\n      parser.add_node(child);\n    }\n    return parser.parsed;\n  };\n\n  AbstractChosen = (function() {\n    function AbstractChosen(form_field, options) {\n      this.form_field = form_field;\n      this.options = options != null ? options : {};\n      if (!AbstractChosen.browser_is_supported()) {\n        return;\n      }\n      this.is_multiple = this.form_field.multiple;\n      this.set_default_text();\n      this.set_default_values();\n      this.setup();\n      this.set_up_html();\n      this.register_observers();\n      this.on_ready();\n    }\n\n    AbstractChosen.prototype.set_default_values = function() {\n      var _this = this;\n      this.click_test_action = function(evt) {\n        return _this.test_active_click(evt);\n      };\n      this.activate_action = function(evt) {\n        return _this.activate_field(evt);\n      };\n      this.active_field = false;\n      this.mouse_on_container = false;\n      this.results_showing = false;\n      this.result_highlighted = null;\n      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === \"\" ? this.options.allow_single_deselect : false;\n      this.disable_search_threshold = this.options.disable_search_threshold || 0;\n      this.disable_search = this.options.disable_search || false;\n      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;\n      this.group_search = this.options.group_search != null ? this.options.group_search : true;\n      this.search_contains = this.options.search_contains || false;\n      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;\n      this.max_selected_options = this.options.max_selected_options || Infinity;\n      this.inherit_select_classes = this.options.inherit_select_classes || false;\n      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;\n      this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;\n      this.include_group_label_in_selected = this.options.include_group_label_in_selected || false;\n      return this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY;\n    };\n\n    AbstractChosen.prototype.set_default_text = function() {\n      if (this.form_field.getAttribute(\"data-placeholder\")) {\n        this.default_text = this.form_field.getAttribute(\"data-placeholder\");\n      } else if (this.is_multiple) {\n        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;\n      } else {\n        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;\n      }\n      return this.results_none_found = this.form_field.getAttribute(\"data-no_results_text\") || this.options.no_results_text || AbstractChosen.default_no_result_text;\n    };\n\n    AbstractChosen.prototype.choice_label = function(item) {\n      if (this.include_group_label_in_selected && (item.group_label != null)) {\n        return \"<b class='group-name'>\" + item.group_label + \"</b>\" + item.html;\n      } else {\n        return item.html;\n      }\n    };\n\n    AbstractChosen.prototype.mouse_enter = function() {\n      return this.mouse_on_container = true;\n    };\n\n    AbstractChosen.prototype.mouse_leave = function() {\n      return this.mouse_on_container = false;\n    };\n\n    AbstractChosen.prototype.input_focus = function(evt) {\n      var _this = this;\n      if (this.is_multiple) {\n        if (!this.active_field) {\n          return setTimeout((function() {\n            return _this.container_mousedown();\n          }), 50);\n        }\n      } else {\n        if (!this.active_field) {\n          return this.activate_field();\n        }\n      }\n    };\n\n    AbstractChosen.prototype.input_blur = function(evt) {\n      var _this = this;\n      if (!this.mouse_on_container) {\n        this.active_field = false;\n        return setTimeout((function() {\n          return _this.blur_test();\n        }), 100);\n      }\n    };\n\n    AbstractChosen.prototype.results_option_build = function(options) {\n      var content, data, data_content, shown_results, _i, _len, _ref;\n      content = '';\n      shown_results = 0;\n      _ref = this.results_data;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        data = _ref[_i];\n        data_content = '';\n        if (data.group) {\n          data_content = this.result_add_group(data);\n        } else {\n          data_content = this.result_add_option(data);\n        }\n        if (data_content !== '') {\n          shown_results++;\n          content += data_content;\n        }\n        if (options != null ? options.first : void 0) {\n          if (data.selected && this.is_multiple) {\n            this.choice_build(data);\n          } else if (data.selected && !this.is_multiple) {\n            this.single_set_selected_text(this.choice_label(data));\n          }\n        }\n        if (shown_results >= this.max_shown_results) {\n          break;\n        }\n      }\n      return content;\n    };\n\n    AbstractChosen.prototype.result_add_option = function(option) {\n      var classes, option_el;\n      if (!option.search_match) {\n        return '';\n      }\n      if (!this.include_option_in_results(option)) {\n        return '';\n      }\n      classes = [];\n      if (!option.disabled && !(option.selected && this.is_multiple)) {\n        classes.push(\"active-result\");\n      }\n      if (option.disabled && !(option.selected && this.is_multiple)) {\n        classes.push(\"disabled-result\");\n      }\n      if (option.selected) {\n        classes.push(\"result-selected\");\n      }\n      if (option.group_array_index != null) {\n        classes.push(\"group-option\");\n      }\n      if (option.classes !== \"\") {\n        classes.push(option.classes);\n      }\n      option_el = document.createElement(\"li\");\n      option_el.className = classes.join(\" \");\n      option_el.style.cssText = option.style;\n      option_el.setAttribute(\"data-option-array-index\", option.array_index);\n      option_el.innerHTML = option.search_text;\n      if (option.title) {\n        option_el.title = option.title;\n      }\n      return this.outerHTML(option_el);\n    };\n\n    AbstractChosen.prototype.result_add_group = function(group) {\n      var classes, group_el;\n      if (!(group.search_match || group.group_match)) {\n        return '';\n      }\n      if (!(group.active_options > 0)) {\n        return '';\n      }\n      classes = [];\n      classes.push(\"group-result\");\n      if (group.classes) {\n        classes.push(group.classes);\n      }\n      group_el = document.createElement(\"li\");\n      group_el.className = classes.join(\" \");\n      group_el.innerHTML = group.search_text;\n      if (group.title) {\n        group_el.title = group.title;\n      }\n      return this.outerHTML(group_el);\n    };\n\n    AbstractChosen.prototype.results_update_field = function() {\n      this.set_default_text();\n      if (!this.is_multiple) {\n        this.results_reset_cleanup();\n      }\n      this.result_clear_highlight();\n      this.results_build();\n      if (this.results_showing) {\n        return this.winnow_results();\n      }\n    };\n\n    AbstractChosen.prototype.reset_single_select_options = function() {\n      var result, _i, _len, _ref, _results;\n      _ref = this.results_data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        result = _ref[_i];\n        if (result.selected) {\n          _results.push(result.selected = false);\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    AbstractChosen.prototype.results_toggle = function() {\n      if (this.results_showing) {\n        return this.results_hide();\n      } else {\n        return this.results_show();\n      }\n    };\n\n    AbstractChosen.prototype.results_search = function(evt) {\n      if (this.results_showing) {\n        return this.winnow_results();\n      } else {\n        return this.results_show();\n      }\n    };\n\n    AbstractChosen.prototype.winnow_results = function() {\n      var escapedSearchText, option, regex, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;\n      this.no_results_clear();\n      results = 0;\n      searchText = this.get_search_text();\n      escapedSearchText = searchText.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n      zregex = new RegExp(escapedSearchText, 'i');\n      regex = this.get_search_regex(escapedSearchText);\n      _ref = this.results_data;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        option = _ref[_i];\n        option.search_match = false;\n        results_group = null;\n        if (this.include_option_in_results(option)) {\n          if (option.group) {\n            option.group_match = false;\n            option.active_options = 0;\n          }\n          if ((option.group_array_index != null) && this.results_data[option.group_array_index]) {\n            results_group = this.results_data[option.group_array_index];\n            if (results_group.active_options === 0 && results_group.search_match) {\n              results += 1;\n            }\n            results_group.active_options += 1;\n          }\n          option.search_text = option.group ? option.label : option.html;\n          if (!(option.group && !this.group_search)) {\n            option.search_match = this.search_string_match(option.search_text, regex);\n            if (option.search_match && !option.group) {\n              results += 1;\n            }\n            if (option.search_match) {\n              if (searchText.length) {\n                startpos = option.search_text.search(zregex);\n                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);\n                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);\n              }\n              if (results_group != null) {\n                results_group.group_match = true;\n              }\n            } else if ((option.group_array_index != null) && this.results_data[option.group_array_index].search_match) {\n              option.search_match = true;\n            }\n          }\n        }\n      }\n      this.result_clear_highlight();\n      if (results < 1 && searchText.length) {\n        this.update_results_content(\"\");\n        return this.no_results(searchText);\n      } else {\n        this.update_results_content(this.results_option_build());\n        return this.winnow_results_set_highlight();\n      }\n    };\n\n    AbstractChosen.prototype.get_search_regex = function(escaped_search_string) {\n      var regex_anchor;\n      regex_anchor = this.search_contains ? \"\" : \"^\";\n      return new RegExp(regex_anchor + escaped_search_string, 'i');\n    };\n\n    AbstractChosen.prototype.search_string_match = function(search_string, regex) {\n      var part, parts, _i, _len;\n      if (regex.test(search_string)) {\n        return true;\n      } else if (this.enable_split_word_search && (search_string.indexOf(\" \") >= 0 || search_string.indexOf(\"[\") === 0)) {\n        parts = search_string.replace(/\\[|\\]/g, \"\").split(\" \");\n        if (parts.length) {\n          for (_i = 0, _len = parts.length; _i < _len; _i++) {\n            part = parts[_i];\n            if (regex.test(part)) {\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    AbstractChosen.prototype.choices_count = function() {\n      var option, _i, _len, _ref;\n      if (this.selected_option_count != null) {\n        return this.selected_option_count;\n      }\n      this.selected_option_count = 0;\n      _ref = this.form_field.options;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        option = _ref[_i];\n        if (option.selected) {\n          this.selected_option_count += 1;\n        }\n      }\n      return this.selected_option_count;\n    };\n\n    AbstractChosen.prototype.choices_click = function(evt) {\n      evt.preventDefault();\n      if (!(this.results_showing || this.is_disabled)) {\n        return this.results_show();\n      }\n    };\n\n    AbstractChosen.prototype.keyup_checker = function(evt) {\n      var stroke, _ref;\n      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;\n      this.search_field_scale();\n      switch (stroke) {\n        case 8:\n          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {\n            return this.keydown_backstroke();\n          } else if (!this.pending_backstroke) {\n            this.result_clear_highlight();\n            return this.results_search();\n          }\n          break;\n        case 13:\n          evt.preventDefault();\n          if (this.results_showing) {\n            return this.result_select(evt);\n          }\n          break;\n        case 27:\n          if (this.results_showing) {\n            this.results_hide();\n          }\n          return true;\n        case 9:\n        case 38:\n        case 40:\n        case 16:\n        case 91:\n        case 17:\n        case 18:\n          break;\n        default:\n          return this.results_search();\n      }\n    };\n\n    AbstractChosen.prototype.clipboard_event_checker = function(evt) {\n      var _this = this;\n      return setTimeout((function() {\n        return _this.results_search();\n      }), 50);\n    };\n\n    AbstractChosen.prototype.container_width = function() {\n      if (this.options.width != null) {\n        return this.options.width;\n      } else {\n        return \"\" + this.form_field.offsetWidth + \"px\";\n      }\n    };\n\n    AbstractChosen.prototype.container_styles = function() {\n\t\t\tvar styles = {},\n\t\t\t\t\tstyle = [];\n\n\t\t\tif(typeof this.options.styles !== 'undefined') {\n\t\t\t\tstyles = this.options.styles;\n\t\t\t}\n\t\t\tstyles.width = this.container_width();\n\n\t\t\t$.each(styles, function(key, value) {\n\t\t\t\tstyle.push(key + ':' + value);\n\t\t\t});\n\n\t\t\treturn style.join(';');\n    };\n\n    AbstractChosen.prototype.include_option_in_results = function(option) {\n      if (this.is_multiple && (!this.display_selected_options && option.selected)) {\n        return false;\n      }\n      if (!this.display_disabled_options && option.disabled) {\n        return false;\n      }\n      if (option.empty) {\n        return false;\n      }\n      return true;\n    };\n\n    AbstractChosen.prototype.search_results_touchstart = function(evt) {\n      this.touch_started = true;\n      return this.search_results_mouseover(evt);\n    };\n\n    AbstractChosen.prototype.search_results_touchmove = function(evt) {\n      this.touch_started = false;\n      return this.search_results_mouseout(evt);\n    };\n\n    AbstractChosen.prototype.search_results_touchend = function(evt) {\n      if (this.touch_started) {\n        return this.search_results_mouseup(evt);\n      }\n    };\n\n    AbstractChosen.prototype.outerHTML = function(element) {\n      var tmp;\n      if (element.outerHTML) {\n        return element.outerHTML;\n      }\n      tmp = document.createElement(\"div\");\n      tmp.appendChild(element);\n      return tmp.innerHTML;\n    };\n\n    AbstractChosen.browser_is_supported = function() {\n      if (/iP(od|hone)/i.test(window.navigator.userAgent)) {\n        return false;\n      }\n      if (/Android/i.test(window.navigator.userAgent)) {\n        if (/Mobile/i.test(window.navigator.userAgent)) {\n          return false;\n        }\n      }\n      if (/IEMobile/i.test(window.navigator.userAgent)) {\n        return false;\n      }\n      if (/Windows Phone/i.test(window.navigator.userAgent)) {\n        return false;\n      }\n      if (/BlackBerry/i.test(window.navigator.userAgent)) {\n        return false;\n      }\n      if (/BB10/i.test(window.navigator.userAgent)) {\n        return false;\n      }\n      if (window.navigator.appName === \"Microsoft Internet Explorer\") {\n        return document.documentMode >= 8;\n      }\n      return true;\n    };\n\n    AbstractChosen.default_multiple_text = \"Select Some Options\";\n\n    AbstractChosen.default_single_text = \"Select an Option\";\n\n    AbstractChosen.default_no_result_text = \"No results match\";\n\n    return AbstractChosen;\n\n  })();\n\n  $ = jQuery;\n\n  $.fn.extend({\n    chosen: function(options) {\n      if (!AbstractChosen.browser_is_supported()) {\n        return this;\n      }\n      return this.each(function(input_field) {\n        var $this, chosen;\n        $this = $(this);\n        chosen = $this.data('chosen');\n        if (options === 'destroy') {\n          if (chosen instanceof Chosen) {\n            chosen.destroy();\n          }\n          return;\n        }\n        if (!(chosen instanceof Chosen)) {\n          $this.data('chosen', new Chosen(this, options));\n        }\n      });\n    }\n  });\n\n  Chosen = (function(_super) {\n    __extends(Chosen, _super);\n\n    function Chosen() {\n      _ref = Chosen.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    Chosen.prototype.setup = function() {\n      this.form_field_jq = $(this.form_field);\n      this.current_selectedIndex = this.form_field.selectedIndex;\n      return this.is_rtl = this.form_field_jq.hasClass(\"chosen-rtl\");\n    };\n\n    Chosen.prototype.set_up_html = function() {\n      var container_classes, container_props;\n      container_classes = [\"chosen-container\"];\n      container_classes.push(\"chosen-container-\" + (this.is_multiple ? \"multi\" : \"single\"));\n      if (this.inherit_select_classes && this.form_field.className) {\n        container_classes.push(this.form_field.className);\n      }\n      if (this.is_rtl) {\n        container_classes.push(\"chosen-rtl\");\n      }\n      container_props = {\n        'class': container_classes.join(' '),\n        'style': this.container_styles(),\n        'title': this.form_field.title\n      };\n      if (this.form_field.id.length) {\n        container_props.id = this.form_field.id.replace(/[^\\w]/g, '_') + \"_chosen\";\n      }\n      this.container = $(\"<div />\", container_props);\n      if (this.is_multiple) {\n        this.container.html('<ul class=\"chosen-choices\"><li class=\"search-field\"><input type=\"text\" value=\"' + this.default_text + '\" class=\"default\" autocomplete=\"off\" style=\"width:25px;\" /></li></ul><div class=\"chosen-drop\"><ul class=\"chosen-results\"></ul></div>');\n      } else {\n        this.container.html('<a class=\"chosen-single chosen-default\"><span>' + this.default_text + '</span><div><b></b></div></a><div class=\"chosen-drop\"><div class=\"chosen-search\"><input type=\"text\" autocomplete=\"off\" /></div><ul class=\"chosen-results\"></ul></div>');\n      }\n      this.form_field_jq.hide().after(this.container);\n      this.dropdown = this.container.find('div.chosen-drop').first();\n      this.search_field = this.container.find('input').first();\n      this.search_results = this.container.find('ul.chosen-results').first();\n      this.search_field_scale();\n      this.search_no_results = this.container.find('li.no-results').first();\n      if (this.is_multiple) {\n        this.search_choices = this.container.find('ul.chosen-choices').first();\n        this.search_container = this.container.find('li.search-field').first();\n      } else {\n        this.search_container = this.container.find('div.chosen-search').first();\n        this.selected_item = this.container.find('.chosen-single').first();\n      }\n      this.results_build();\n      this.set_tab_index();\n      return this.set_label_behavior();\n    };\n\n    Chosen.prototype.on_ready = function() {\n      return this.form_field_jq.trigger(\"chosen:ready\", {\n        chosen: this\n      });\n    };\n\n    Chosen.prototype.register_observers = function() {\n      var _this = this;\n      this.container.bind('touchstart.chosen', function(evt) {\n        _this.container_mousedown(evt);\n        return evt.preventDefault();\n      });\n      this.container.bind('touchend.chosen', function(evt) {\n        _this.container_mouseup(evt);\n        return evt.preventDefault();\n      });\n      this.container.bind('mousedown.chosen', function(evt) {\n        _this.container_mousedown(evt);\n      });\n      this.container.bind('mouseup.chosen', function(evt) {\n        _this.container_mouseup(evt);\n      });\n      this.container.bind('mouseenter.chosen', function(evt) {\n        _this.mouse_enter(evt);\n      });\n      this.container.bind('mouseleave.chosen', function(evt) {\n        _this.mouse_leave(evt);\n      });\n      this.search_results.bind('mouseup.chosen', function(evt) {\n        _this.search_results_mouseup(evt);\n      });\n      this.search_results.bind('mouseover.chosen', function(evt) {\n        _this.search_results_mouseover(evt);\n      });\n      this.search_results.bind('mouseout.chosen', function(evt) {\n        _this.search_results_mouseout(evt);\n      });\n      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function(evt) {\n        _this.search_results_mousewheel(evt);\n      });\n      this.search_results.bind('touchstart.chosen', function(evt) {\n        _this.search_results_touchstart(evt);\n      });\n      this.search_results.bind('touchmove.chosen', function(evt) {\n        _this.search_results_touchmove(evt);\n      });\n      this.search_results.bind('touchend.chosen', function(evt) {\n        _this.search_results_touchend(evt);\n      });\n      this.form_field_jq.bind(\"chosen:updated.chosen\", function(evt) {\n        _this.results_update_field(evt);\n      });\n      this.form_field_jq.bind(\"chosen:activate.chosen\", function(evt) {\n        _this.activate_field(evt);\n      });\n      this.form_field_jq.bind(\"chosen:open.chosen\", function(evt) {\n        _this.container_mousedown(evt);\n      });\n      this.form_field_jq.bind(\"chosen:close.chosen\", function(evt) {\n        _this.input_blur(evt);\n      });\n      this.search_field.bind('blur.chosen', function(evt) {\n        _this.input_blur(evt);\n      });\n      this.search_field.bind('keyup.chosen', function(evt) {\n        _this.keyup_checker(evt);\n      });\n      this.search_field.bind('keydown.chosen', function(evt) {\n        _this.keydown_checker(evt);\n      });\n      this.search_field.bind('focus.chosen', function(evt) {\n        _this.input_focus(evt);\n      });\n      this.search_field.bind('cut.chosen', function(evt) {\n        _this.clipboard_event_checker(evt);\n      });\n      this.search_field.bind('paste.chosen', function(evt) {\n        _this.clipboard_event_checker(evt);\n      });\n      if (this.is_multiple) {\n        return this.search_choices.bind('click.chosen', function(evt) {\n          _this.choices_click(evt);\n        });\n      } else {\n        return this.container.bind('click.chosen', function(evt) {\n          evt.preventDefault();\n        });\n      }\n    };\n\n    Chosen.prototype.destroy = function() {\n      $(this.container[0].ownerDocument).unbind(\"click.chosen\", this.click_test_action);\n      if (this.search_field[0].tabIndex) {\n        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;\n      }\n      this.container.remove();\n      this.form_field_jq.removeData('chosen');\n      return this.form_field_jq.show();\n    };\n\n    Chosen.prototype.search_field_disabled = function() {\n      this.is_disabled = this.form_field_jq[0].disabled;\n      if (this.is_disabled) {\n        this.container.addClass('chosen-disabled');\n        this.search_field[0].disabled = true;\n        if (!this.is_multiple) {\n          this.selected_item.unbind(\"focus.chosen\", this.activate_action);\n        }\n        return this.close_field();\n      } else {\n        this.container.removeClass('chosen-disabled');\n        this.search_field[0].disabled = false;\n        if (!this.is_multiple) {\n          return this.selected_item.bind(\"focus.chosen\", this.activate_action);\n        }\n      }\n    };\n\n    Chosen.prototype.container_mousedown = function(evt) {\n      if (!this.is_disabled) {\n        if (evt && evt.type === \"mousedown\" && !this.results_showing) {\n          evt.preventDefault();\n        }\n        if (!((evt != null) && ($(evt.target)).hasClass(\"search-choice-close\"))) {\n          if (!this.active_field) {\n            if (this.is_multiple) {\n              this.search_field.val(\"\");\n            }\n            $(this.container[0].ownerDocument).bind('click.chosen', this.click_test_action);\n            this.results_show();\n          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents(\"a.chosen-single\").length)) {\n            evt.preventDefault();\n            this.results_toggle();\n          }\n          return this.activate_field();\n        }\n      }\n    };\n\n    Chosen.prototype.container_mouseup = function(evt) {\n      if (evt.target.nodeName === \"ABBR\" && !this.is_disabled) {\n        return this.results_reset(evt);\n      }\n    };\n\n    Chosen.prototype.search_results_mousewheel = function(evt) {\n      var delta;\n      if (evt.originalEvent) {\n        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;\n      }\n      if (delta != null) {\n        evt.preventDefault();\n        if (evt.type === 'DOMMouseScroll') {\n          delta = delta * 40;\n        }\n        return this.search_results.scrollTop(delta + this.search_results.scrollTop());\n      }\n    };\n\n    Chosen.prototype.blur_test = function(evt) {\n      if (!this.active_field && this.container.hasClass(\"chosen-container-active\")) {\n        return this.close_field();\n      }\n    };\n\n    Chosen.prototype.close_field = function() {\n      $(this.container[0].ownerDocument).unbind(\"click.chosen\", this.click_test_action);\n      this.active_field = false;\n      this.results_hide();\n      this.container.removeClass(\"chosen-container-active\");\n      this.clear_backstroke();\n      this.show_search_field_default();\n      return this.search_field_scale();\n    };\n\n    Chosen.prototype.activate_field = function() {\n      this.container.addClass(\"chosen-container-active\");\n      this.active_field = true;\n      this.search_field.val(this.search_field.val());\n      return this.search_field.focus();\n    };\n\n    Chosen.prototype.test_active_click = function(evt) {\n      var active_container;\n      active_container = $(evt.target).closest('.chosen-container');\n      if (active_container.length && this.container[0] === active_container[0]) {\n        return this.active_field = true;\n      } else {\n        return this.close_field();\n      }\n    };\n\n    Chosen.prototype.results_build = function() {\n      this.parsing = true;\n      this.selected_option_count = null;\n      this.results_data = SelectParser.select_to_array(this.form_field);\n      if (this.is_multiple) {\n        this.search_choices.find(\"li.search-choice\").remove();\n      } else if (!this.is_multiple) {\n        this.single_set_selected_text();\n        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {\n          this.search_field[0].readOnly = true;\n          this.container.addClass(\"chosen-container-single-nosearch\");\n        } else {\n          this.search_field[0].readOnly = false;\n          this.container.removeClass(\"chosen-container-single-nosearch\");\n        }\n      }\n      this.update_results_content(this.results_option_build({\n        first: true\n      }));\n      this.search_field_disabled();\n      this.show_search_field_default();\n      this.search_field_scale();\n      return this.parsing = false;\n    };\n\n    Chosen.prototype.result_do_highlight = function(el) {\n      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;\n      if (el.length) {\n        this.result_clear_highlight();\n        this.result_highlight = el;\n        this.result_highlight.addClass(\"highlighted\");\n        maxHeight = parseInt(this.search_results.css(\"maxHeight\"), 10);\n        visible_top = this.search_results.scrollTop();\n        visible_bottom = maxHeight + visible_top;\n        high_top = this.result_highlight.position().top + this.search_results.scrollTop();\n        high_bottom = high_top + this.result_highlight.outerHeight();\n        if (high_bottom >= visible_bottom) {\n          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);\n        } else if (high_top < visible_top) {\n          return this.search_results.scrollTop(high_top);\n        }\n      }\n    };\n\n    Chosen.prototype.result_clear_highlight = function() {\n      if (this.result_highlight) {\n        this.result_highlight.removeClass(\"highlighted\");\n      }\n      return this.result_highlight = null;\n    };\n\n    Chosen.prototype.results_show = function() {\n      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {\n        this.form_field_jq.trigger(\"chosen:maxselected\", {\n          chosen: this\n        });\n        return false;\n      }\n      this.container.addClass(\"chosen-with-drop\");\n      this.results_showing = true;\n      this.search_field.focus();\n      this.search_field.val(this.search_field.val());\n      this.winnow_results();\n      return this.form_field_jq.trigger(\"chosen:showing_dropdown\", {\n        chosen: this\n      });\n    };\n\n    Chosen.prototype.update_results_content = function(content) {\n      return this.search_results.html(content);\n    };\n\n    Chosen.prototype.results_hide = function() {\n      if (this.results_showing) {\n        this.result_clear_highlight();\n        this.container.removeClass(\"chosen-with-drop\");\n        this.form_field_jq.trigger(\"chosen:hiding_dropdown\", {\n          chosen: this\n        });\n      }\n      return this.results_showing = false;\n    };\n\n    Chosen.prototype.set_tab_index = function(el) {\n      var ti;\n      if (this.form_field.tabIndex) {\n        ti = this.form_field.tabIndex;\n        this.form_field.tabIndex = -1;\n        return this.search_field[0].tabIndex = ti;\n      }\n    };\n\n    Chosen.prototype.set_label_behavior = function() {\n      var _this = this;\n      this.form_field_label = this.form_field_jq.parents(\"label\");\n      if (!this.form_field_label.length && this.form_field.id.length) {\n        this.form_field_label = $(\"label[for='\" + this.form_field.id + \"']\");\n      }\n      if (this.form_field_label.length > 0) {\n        return this.form_field_label.bind('click.chosen', function(evt) {\n          if (_this.is_multiple) {\n            return _this.container_mousedown(evt);\n          } else {\n            return _this.activate_field();\n          }\n        });\n      }\n    };\n\n    Chosen.prototype.show_search_field_default = function() {\n      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {\n        this.search_field.val(this.default_text);\n        return this.search_field.addClass(\"default\");\n      } else {\n        this.search_field.val(\"\");\n        return this.search_field.removeClass(\"default\");\n      }\n    };\n\n    Chosen.prototype.search_results_mouseup = function(evt) {\n      var target;\n      target = $(evt.target).hasClass(\"active-result\") ? $(evt.target) : $(evt.target).parents(\".active-result\").first();\n      if (target.length) {\n        this.result_highlight = target;\n        this.result_select(evt);\n        return this.search_field.focus();\n      }\n    };\n\n    Chosen.prototype.search_results_mouseover = function(evt) {\n      var target;\n      target = $(evt.target).hasClass(\"active-result\") ? $(evt.target) : $(evt.target).parents(\".active-result\").first();\n      if (target) {\n        return this.result_do_highlight(target);\n      }\n    };\n\n    Chosen.prototype.search_results_mouseout = function(evt) {\n      if ($(evt.target).hasClass(\"active-result\" || $(evt.target).parents('.active-result').first())) {\n        return this.result_clear_highlight();\n      }\n    };\n\n    Chosen.prototype.choice_build = function(item) {\n      var choice, close_link,\n\t\t\t\t\t_this = this,\n\t\t\t\t\tlabel = \"<span>\" + (this.choice_label(item)) + \"</span>\",\n\t\t\t\t\t$option = $('option:eq('+item.options_index+')', this.form_field)\n\n\t\t\t// Check if the option has an img data attribute, if so add an image to the choice\n\t\t\tif(typeof $option !== \"undefined\" && $option.length && typeof $option.data('img') !== \"undefined\" && $option.data('img').length) {\n\t\t\t\timage = '<img src=\"' + $option.data('img') + '\">';\n\t\t\t\tlabel = image + label;\n\t\t\t}\n\n      choice = $('<li />', {\n        \"class\": \"search-choice\"\n      }).html(label);\n      if (item.disabled) {\n        choice.addClass('search-choice-disabled');\n      } else {\n        close_link = $('<a />', {\n          \"class\": 'search-choice-close',\n          'data-option-array-index': item.array_index\n        });\n        close_link.bind('click.chosen', function(evt) {\n          return _this.choice_destroy_link_click(evt);\n        });\n        choice.append(close_link);\n      }\n      return this.search_container.before(choice);\n    };\n\n    Chosen.prototype.choice_destroy_link_click = function(evt) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      if (!this.is_disabled) {\n        return this.choice_destroy($(evt.target));\n      }\n    };\n\n    Chosen.prototype.choice_destroy = function(link) {\n      if (this.result_deselect(link[0].getAttribute(\"data-option-array-index\"))) {\n        this.show_search_field_default();\n        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {\n          this.results_hide();\n        }\n        link.parents('li').first().remove();\n        return this.search_field_scale();\n      }\n    };\n\n    Chosen.prototype.results_reset = function() {\n      this.reset_single_select_options();\n      this.form_field.options[0].selected = true;\n      this.single_set_selected_text();\n      this.show_search_field_default();\n      this.results_reset_cleanup();\n      this.form_field_jq.trigger(\"change\");\n      if (this.active_field) {\n        return this.results_hide();\n      }\n    };\n\n    Chosen.prototype.results_reset_cleanup = function() {\n      this.current_selectedIndex = this.form_field.selectedIndex;\n      return this.selected_item.find(\"abbr\").remove();\n    };\n\n    Chosen.prototype.result_select = function(evt) {\n      var high, item;\n      if (this.result_highlight) {\n        high = this.result_highlight;\n        this.result_clear_highlight();\n        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {\n          this.form_field_jq.trigger(\"chosen:maxselected\", {\n            chosen: this\n          });\n          return false;\n        }\n        if (this.is_multiple) {\n          high.removeClass(\"active-result\");\n        } else {\n          this.reset_single_select_options();\n        }\n        high.addClass(\"result-selected\");\n        item = this.results_data[high[0].getAttribute(\"data-option-array-index\")];\n        item.selected = true;\n        this.form_field.options[item.options_index].selected = true;\n        this.selected_option_count = null;\n        if (this.is_multiple) {\n          this.choice_build(item);\n        } else {\n          this.single_set_selected_text(this.choice_label(item));\n        }\n        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {\n          this.results_hide();\n        }\n        this.show_search_field_default();\n        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {\n          this.form_field_jq.trigger(\"change\", {\n            'selected': this.form_field.options[item.options_index].value\n          });\n        }\n        this.current_selectedIndex = this.form_field.selectedIndex;\n        evt.preventDefault();\n        return this.search_field_scale();\n      }\n    };\n\n    Chosen.prototype.single_set_selected_text = function(text) {\n      if (text == null) {\n        text = this.default_text;\n      }\n      if (text === this.default_text) {\n        this.selected_item.addClass(\"chosen-default\");\n      } else {\n        this.single_deselect_control_build();\n        this.selected_item.removeClass(\"chosen-default\");\n      }\n      return this.selected_item.find(\"span\").html(text);\n    };\n\n    Chosen.prototype.result_deselect = function(pos) {\n      var result_data;\n      result_data = this.results_data[pos];\n      if (!this.form_field.options[result_data.options_index].disabled) {\n        result_data.selected = false;\n        this.form_field.options[result_data.options_index].selected = false;\n        this.selected_option_count = null;\n        this.result_clear_highlight();\n        if (this.results_showing) {\n          this.winnow_results();\n        }\n        this.form_field_jq.trigger(\"change\", {\n          deselected: this.form_field.options[result_data.options_index].value\n        });\n        this.search_field_scale();\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    Chosen.prototype.single_deselect_control_build = function() {\n      if (!this.allow_single_deselect) {\n        return;\n      }\n      if (!this.selected_item.find(\"abbr\").length) {\n        this.selected_item.find(\"span\").first().after(\"<abbr class=\\\"search-choice-close\\\"></abbr>\");\n      }\n      return this.selected_item.addClass(\"chosen-single-with-deselect\");\n    };\n\n    Chosen.prototype.get_search_text = function() {\n      return $('<div/>').text($.trim(this.search_field.val())).html();\n    };\n\n    Chosen.prototype.winnow_results_set_highlight = function() {\n      var do_high, selected_results;\n      selected_results = !this.is_multiple ? this.search_results.find(\".result-selected.active-result\") : [];\n      do_high = selected_results.length ? selected_results.first() : this.search_results.find(\".active-result\").first();\n      if (do_high != null) {\n        return this.result_do_highlight(do_high);\n      }\n    };\n\n    Chosen.prototype.no_results = function(terms) {\n      var no_results_html;\n      no_results_html = $('<li class=\"no-results\">' + this.results_none_found + ' \"<span></span>\"</li>');\n      no_results_html.find(\"span\").first().html(terms);\n      this.search_results.append(no_results_html);\n      return this.form_field_jq.trigger(\"chosen:no_results\", {\n        chosen: this\n      });\n    };\n\n    Chosen.prototype.no_results_clear = function() {\n      return this.search_results.find(\".no-results\").remove();\n    };\n\n    Chosen.prototype.keydown_arrow = function() {\n      var next_sib;\n      if (this.results_showing && this.result_highlight) {\n        next_sib = this.result_highlight.nextAll(\"li.active-result\").first();\n        if (next_sib) {\n          return this.result_do_highlight(next_sib);\n        }\n      } else {\n        return this.results_show();\n      }\n    };\n\n    Chosen.prototype.keyup_arrow = function() {\n      var prev_sibs;\n      if (!this.results_showing && !this.is_multiple) {\n        return this.results_show();\n      } else if (this.result_highlight) {\n        prev_sibs = this.result_highlight.prevAll(\"li.active-result\");\n        if (prev_sibs.length) {\n          return this.result_do_highlight(prev_sibs.first());\n        } else {\n          if (this.choices_count() > 0) {\n            this.results_hide();\n          }\n          return this.result_clear_highlight();\n        }\n      }\n    };\n\n    Chosen.prototype.keydown_backstroke = function() {\n      var next_available_destroy;\n      if (this.pending_backstroke) {\n        this.choice_destroy(this.pending_backstroke.find(\"a\").first());\n        return this.clear_backstroke();\n      } else {\n        next_available_destroy = this.search_container.siblings(\"li.search-choice\").last();\n        if (next_available_destroy.length && !next_available_destroy.hasClass(\"search-choice-disabled\")) {\n          this.pending_backstroke = next_available_destroy;\n          if (this.single_backstroke_delete) {\n            return this.keydown_backstroke();\n          } else {\n            return this.pending_backstroke.addClass(\"search-choice-focus\");\n          }\n        }\n      }\n    };\n\n    Chosen.prototype.clear_backstroke = function() {\n      if (this.pending_backstroke) {\n        this.pending_backstroke.removeClass(\"search-choice-focus\");\n      }\n      return this.pending_backstroke = null;\n    };\n\n    Chosen.prototype.keydown_checker = function(evt) {\n      var stroke, _ref1;\n      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;\n      this.search_field_scale();\n      if (stroke !== 8 && this.pending_backstroke) {\n        this.clear_backstroke();\n      }\n      switch (stroke) {\n        case 8:\n          this.backstroke_length = this.search_field.val().length;\n          break;\n        case 9:\n          if (this.results_showing && !this.is_multiple) {\n            this.result_select(evt);\n          }\n          this.mouse_on_container = false;\n          break;\n        case 13:\n          if (this.results_showing) {\n            evt.preventDefault();\n          }\n          break;\n        case 32:\n          if (this.disable_search) {\n            evt.preventDefault();\n          }\n          break;\n        case 38:\n          evt.preventDefault();\n          this.keyup_arrow();\n          break;\n        case 40:\n          evt.preventDefault();\n          this.keydown_arrow();\n          break;\n      }\n    };\n\n    Chosen.prototype.search_field_scale = function() {\n      var div, f_width, h, style, style_block, styles, w, _i, _len;\n      if (this.is_multiple) {\n        h = 0;\n        w = 0;\n        style_block = \"position:absolute; left: -1000px; top: -1000px; display:none;\";\n        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];\n        for (_i = 0, _len = styles.length; _i < _len; _i++) {\n          style = styles[_i];\n          style_block += style + \":\" + this.search_field.css(style) + \";\";\n        }\n        div = $('<div />', {\n          'style': style_block\n        });\n        div.text(this.search_field.val());\n        $('body').append(div);\n        w = div.width() + 25;\n        div.remove();\n        f_width = this.container.outerWidth();\n        if (w > f_width - 10) {\n          w = f_width - 10;\n        }\n        return this.search_field.css({\n          'width': w + 'px'\n        });\n      }\n    };\n\n    return Chosen;\n\n  })(AbstractChosen);\n\n}).call(this);\n","(function ($) {\n  \"use strict\";\n\n  var defaultOptions = {\n    tagClass: function(item) {\n      return 'label label-info';\n    },\n    itemValue: function(item) {\n      return item ? item.toString() : item;\n    },\n    itemText: function(item) {\n      return this.itemValue(item);\n    },\n    freeInput: true,\n    addOnBlur: true,\n    maxTags: undefined,\n    maxChars: undefined,\n    confirmKeys: [13, 44],\n    onTagExists: function(item, $tag) {\n      $tag.hide().fadeIn();\n    },\n    trimValue: false,\n    allowDuplicates: false\n  };\n\n  /**\n   * Constructor function\n   */\n  function TagsInput(element, options) {\n    this.itemsArray = [];\n\n    this.$element = $(element);\n    this.$element.hide();\n\n    this.isSelect = (element.tagName === 'SELECT');\n    this.multiple = (this.isSelect && element.hasAttribute('multiple'));\n    this.objectItems = options && options.itemValue;\n    this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';\n    this.inputSize = Math.max(1, this.placeholderText.length);\n\n    this.$container = $('<div class=\"bootstrap-tagsinput\"></div>');\n    this.$input = $('<input type=\"text\" placeholder=\"' + this.placeholderText + '\"/>').appendTo(this.$container);\n\n    this.$element.after(this.$container);\n\n    var inputWidth = \"\";\n    this.$input.get(0).style.cssText = \"width: \" + inputWidth + \" !important;\";\n    this.build(options);\n  }\n\n  TagsInput.prototype = {\n    constructor: TagsInput,\n\n    /**\n     * Adds the given item as a new tag. Pass true to dontPushVal to prevent\n     * updating the elements val()\n     */\n    add: function(item, dontPushVal) {\n      var self = this;\n\n      if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags)\n        return;\n\n      // Ignore falsey values, except false\n      if (item !== false && !item)\n        return;\n\n      // Trim value\n      if (typeof item === \"string\" && self.options.trimValue) {\n        item = $.trim(item);\n      }\n\n      // Throw an error when trying to add an object while the itemValue option was not set\n      if (typeof item === \"object\" && !self.objectItems)\n        throw(\"Can't add objects when itemValue option is not set\");\n\n      // Ignore strings only containg whitespace\n      if (item.toString().match(/^\\s*$/))\n        return;\n\n      // If SELECT but not multiple, remove current tag\n      if (self.isSelect && !self.multiple && self.itemsArray.length > 0)\n        self.remove(self.itemsArray[0]);\n\n      if (typeof item === \"string\" && this.$element[0].tagName === 'INPUT') {\n        var items = item.split(',');\n        if (items.length > 1) {\n          for (var i = 0; i < items.length; i++) {\n            this.add(items[i], true);\n          }\n\n          if (!dontPushVal)\n            self.pushVal();\n          return;\n        }\n      }\n\n      var itemValue = self.options.itemValue(item),\n          itemText = self.options.itemText(item),\n          tagClass = self.options.tagClass(item);\n\n      // Ignore items allready added\n      var existing = $.grep(self.itemsArray, function(item) { return self.options.itemValue(item) === itemValue; } )[0];\n      if (existing && !self.options.allowDuplicates) {\n        // Invoke onTagExists\n        if (self.options.onTagExists) {\n          var $existingTag = $(\".tag\", self.$container).filter(function() { return $(this).data(\"item\") === existing; });\n          self.options.onTagExists(item, $existingTag);\n        }\n        return;\n      }\n\n      // if length greater than limit\n      if (self.items().toString().length + item.length + 1 > self.options.maxInputLength)\n        return;\n\n      // raise beforeItemAdd arg\n      var beforeItemAddEvent = $.Event('beforeItemAdd', { item: item, cancel: false });\n      self.$element.trigger(beforeItemAddEvent);\n      if (beforeItemAddEvent.cancel)\n        return;\n\n      // register item in internal array and map\n      self.itemsArray.push(item);\n\n      // add a tag element\n      var $tag = $('<span class=\"tag ' + htmlEncode(tagClass) + '\">' + htmlEncode(itemText) + '<span data-role=\"remove\"></span></span>');\n      $tag.data('item', item);\n      self.findInputWrapper().before($tag);\n      $tag.after(' ');\n\n      // add <option /> if item represents a value not present in one of the <select />'s options\n      if (self.isSelect && !$('option[value=\"' + encodeURIComponent(itemValue) + '\"]',self.$element)[0]) {\n        var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');\n        $option.data('item', item);\n        $option.attr('value', itemValue);\n        self.$element.append($option);\n      }\n\n      if (!dontPushVal)\n        self.pushVal();\n\n      // Add class when reached maxTags\n      if (self.options.maxTags === self.itemsArray.length || self.items().toString().length === self.options.maxInputLength)\n        self.$container.addClass('bootstrap-tagsinput-max');\n\n      self.$element.trigger($.Event('itemAdded', { item: item }));\n    },\n\n    /**\n     * Removes the given item. Pass true to dontPushVal to prevent updating the\n     * elements val()\n     */\n    remove: function(item, dontPushVal) {\n      var self = this;\n\n      if (self.objectItems) {\n        if (typeof item === \"object\")\n          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } );\n        else\n          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } );\n\n        item = item[item.length-1];\n      }\n\n      if (item) {\n        var beforeItemRemoveEvent = $.Event('beforeItemRemove', { item: item, cancel: false });\n        self.$element.trigger(beforeItemRemoveEvent);\n        if (beforeItemRemoveEvent.cancel)\n          return;\n\n        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();\n        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();\n        if($.inArray(item, self.itemsArray) !== -1)\n          self.itemsArray.splice($.inArray(item, self.itemsArray), 1);\n      }\n\n      if (!dontPushVal)\n        self.pushVal();\n\n      // Remove class when reached maxTags\n      if (self.options.maxTags > self.itemsArray.length)\n        self.$container.removeClass('bootstrap-tagsinput-max');\n\n      self.$element.trigger($.Event('itemRemoved',  { item: item }));\n    },\n\n    /**\n     * Removes all items\n     */\n    removeAll: function() {\n      var self = this;\n\n      $('.tag', self.$container).remove();\n      $('option', self.$element).remove();\n\n      while(self.itemsArray.length > 0)\n        self.itemsArray.pop();\n\n      self.pushVal();\n    },\n\n    /**\n     * Refreshes the tags so they match the text/value of their corresponding\n     * item.\n     */\n    refresh: function() {\n      var self = this;\n      $('.tag', self.$container).each(function() {\n        var $tag = $(this),\n            item = $tag.data('item'),\n            itemValue = self.options.itemValue(item),\n            itemText = self.options.itemText(item),\n            tagClass = self.options.tagClass(item);\n\n          // Update tag's class and inner text\n          $tag.attr('class', null);\n          $tag.addClass('tag ' + htmlEncode(tagClass));\n          $tag.contents().filter(function() {\n            return this.nodeType == 3;\n          })[0].nodeValue = htmlEncode(itemText);\n\n          if (self.isSelect) {\n            var option = $('option', self.$element).filter(function() { return $(this).data('item') === item; });\n            option.attr('value', itemValue);\n          }\n      });\n    },\n\n    /**\n     * Returns the items added as tags\n     */\n    items: function() {\n      return this.itemsArray;\n    },\n\n    /**\n     * Assembly value by retrieving the value of each item, and set it on the\n     * element.\n     */\n    pushVal: function() {\n      var self = this,\n          val = $.map(self.items(), function(item) {\n            return self.options.itemValue(item).toString();\n          });\n\n      self.$element.val(val, true).trigger('change');\n    },\n\n    /**\n     * Initializes the tags input behaviour on the element\n     */\n    build: function(options) {\n      var self = this;\n\n      self.options = $.extend({}, defaultOptions, options);\n      // When itemValue is set, freeInput should always be false\n      if (self.objectItems)\n        self.options.freeInput = false;\n\n      makeOptionItemFunction(self.options, 'itemValue');\n      makeOptionItemFunction(self.options, 'itemText');\n      makeOptionFunction(self.options, 'tagClass');\n      \n      // Typeahead Bootstrap version 2.3.2\n      if (self.options.typeahead) {\n        var typeahead = self.options.typeahead || {};\n\n        makeOptionFunction(typeahead, 'source');\n\n        self.$input.typeahead($.extend({}, typeahead, {\n          source: function (query, process) {\n            function processItems(items) {\n              var texts = [];\n\n              for (var i = 0; i < items.length; i++) {\n                var text = self.options.itemText(items[i]);\n                map[text] = items[i];\n                texts.push(text);\n              }\n              process(texts);\n            }\n\n            this.map = {};\n            var map = this.map,\n                data = typeahead.source(query);\n\n            if ($.isFunction(data.success)) {\n              // support for Angular callbacks\n              data.success(processItems);\n            } else if ($.isFunction(data.then)) {\n              // support for Angular promises\n              data.then(processItems);\n            } else {\n              // support for functions and jquery promises\n              $.when(data)\n               .then(processItems);\n            }\n          },\n          updater: function (text) {\n            self.add(this.map[text]);\n          },\n          matcher: function (text) {\n            return (text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1);\n          },\n          sorter: function (texts) {\n            return texts.sort();\n          },\n          highlighter: function (text) {\n            var regex = new RegExp( '(' + this.query + ')', 'gi' );\n            return text.replace( regex, \"<strong>$1</strong>\" );\n          }\n        }));\n      }\n\n      // typeahead.js\n      if (self.options.typeaheadjs) {\n          var typeaheadjs = self.options.typeaheadjs || {};\n          \n          self.$input.typeahead(null, typeaheadjs).on('typeahead:selected', $.proxy(function (obj, datum) {\n            if (typeaheadjs.valueKey)\n              self.add(datum[typeaheadjs.valueKey]);\n            else\n              self.add(datum);\n            self.$input.typeahead('val', '');\n          }, self));\n      }\n\n      self.$container.on('click', $.proxy(function(event) {\n        if (! self.$element.attr('disabled')) {\n          self.$input.removeAttr('disabled');\n        }\n        self.$input.focus();\n      }, self));\n\n        if (self.options.addOnBlur && self.options.freeInput) {\n          self.$input.on('focusout', $.proxy(function(event) {\n              // HACK: only process on focusout when no typeahead opened, to\n              //       avoid adding the typeahead text as tag\n              if ($('.typeahead, .twitter-typeahead', self.$container).length === 0) {\n                self.add(self.$input.val());\n                self.$input.val('');\n              }\n          }, self));\n        }\n        \n\n      self.$container.on('keydown', 'input', $.proxy(function(event) {\n        var $input = $(event.target),\n            $inputWrapper = self.findInputWrapper();\n\n        if (self.$element.attr('disabled')) {\n          self.$input.attr('disabled', 'disabled');\n          return;\n        }\n\n        switch (event.which) {\n          // BACKSPACE\n          case 8:\n            if (doGetCaretPosition($input[0]) === 0) {\n              var prev = $inputWrapper.prev();\n              if (prev) {\n                self.remove(prev.data('item'));\n              }\n            }\n            break;\n\n          // DELETE\n          case 46:\n            if (doGetCaretPosition($input[0]) === 0) {\n              var next = $inputWrapper.next();\n              if (next) {\n                self.remove(next.data('item'));\n              }\n            }\n            break;\n\n          // LEFT ARROW\n          case 37:\n            // Try to move the input before the previous tag\n            var $prevTag = $inputWrapper.prev();\n            if ($input.val().length === 0 && $prevTag[0]) {\n              $prevTag.before($inputWrapper);\n              $input.focus();\n            }\n            break;\n          // RIGHT ARROW\n          case 39:\n            // Try to move the input after the next tag\n            var $nextTag = $inputWrapper.next();\n            if ($input.val().length === 0 && $nextTag[0]) {\n              $nextTag.after($inputWrapper);\n              $input.focus();\n            }\n            break;\n         default:\n             // ignore\n         }\n\n        // Reset internal input's size\n        var textLength = $input.val().length,\n            wordSpace = Math.ceil(textLength / 5),\n            size = textLength + wordSpace + 1;\n        $input.attr('size', Math.max(this.inputSize, $input.val().length));\n      }, self));\n\n      self.$container.on('keypress', 'input', $.proxy(function(event) {\n         var $input = $(event.target);\n\n         if (self.$element.attr('disabled')) {\n            self.$input.attr('disabled', 'disabled');\n            return;\n         }\n\n         var text = $input.val(),\n         maxLengthReached = self.options.maxChars && text.length >= self.options.maxChars;\n         if (self.options.freeInput && (keyCombinationInList(event, self.options.confirmKeys) || maxLengthReached)) {\n            self.add(maxLengthReached ? text.substr(0, self.options.maxChars) : text);\n            $input.val('');\n            event.preventDefault();\n         }\n\n         // Reset internal input's size\n         var textLength = $input.val().length,\n            wordSpace = Math.ceil(textLength / 5),\n            size = textLength + wordSpace + 1;\n         $input.attr('size', Math.max(this.inputSize, $input.val().length));\n      }, self));\n\n      // Remove icon clicked\n      self.$container.on('click', '[data-role=remove]', $.proxy(function(event) {\n        if (self.$element.attr('disabled')) {\n          return;\n        }\n        self.remove($(event.target).closest('.tag').data('item'));\n      }, self));\n\n      // Only add existing value as tags when using strings as tags\n      if (self.options.itemValue === defaultOptions.itemValue) {\n        if (self.$element[0].tagName === 'INPUT') {\n            self.add(self.$element.val());\n        } else {\n          $('option', self.$element).each(function() {\n            self.add($(this).attr('value'), true);\n          });\n        }\n      }\n    },\n\n    /**\n     * Removes all tagsinput behaviour and unregsiter all event handlers\n     */\n    destroy: function() {\n      var self = this;\n\n      // Unbind events\n      self.$container.off('keypress', 'input');\n      self.$container.off('click', '[role=remove]');\n\n      self.$container.remove();\n      self.$element.removeData('tagsinput');\n      self.$element.show();\n    },\n\n    /**\n     * Sets focus on the tagsinput\n     */\n    focus: function() {\n      this.$input.focus();\n    },\n\n    /**\n     * Returns the internal input element\n     */\n    input: function() {\n      return this.$input;\n    },\n\n    /**\n     * Returns the element which is wrapped around the internal input. This\n     * is normally the $container, but typeahead.js moves the $input element.\n     */\n    findInputWrapper: function() {\n      var elt = this.$input[0],\n          container = this.$container[0];\n      while(elt && elt.parentNode !== container)\n        elt = elt.parentNode;\n\n      return $(elt);\n    }\n  };\n\n  /**\n   * Register JQuery plugin\n   */\n  $.fn.tagsinput = function(arg1, arg2) {\n    var results = [];\n\n    this.each(function() {\n      var tagsinput = $(this).data('tagsinput');\n      // Initialize a new tags input\n      if (!tagsinput) {\n          tagsinput = new TagsInput(this, arg1);\n          $(this).data('tagsinput', tagsinput);\n          results.push(tagsinput);\n\n          if (this.tagName === 'SELECT') {\n              $('option', $(this)).attr('selected', 'selected');\n          }\n\n          // Init tags from $(this).val()\n          $(this).val($(this).val());\n      } else if (!arg1 && !arg2) {\n          // tagsinput already exists\n          // no function, trying to init\n          results.push(tagsinput);\n      } else if(tagsinput[arg1] !== undefined) {\n          // Invoke function on existing tags input\n          var retVal = tagsinput[arg1](arg2);\n          if (retVal !== undefined)\n              results.push(retVal);\n      }\n    });\n\n    if ( typeof arg1 == 'string') {\n      // Return the results from the invoked function calls\n      return results.length > 1 ? results : results[0];\n    } else {\n      return results;\n    }\n  };\n\n  $.fn.tagsinput.Constructor = TagsInput;\n\n  /**\n   * Most options support both a string or number as well as a function as\n   * option value. This function makes sure that the option with the given\n   * key in the given options is wrapped in a function\n   */\n  function makeOptionItemFunction(options, key) {\n    if (typeof options[key] !== 'function') {\n      var propertyName = options[key];\n      options[key] = function(item) { return item[propertyName]; };\n    }\n  }\n  function makeOptionFunction(options, key) {\n    if (typeof options[key] !== 'function') {\n      var value = options[key];\n      options[key] = function() { return value; };\n    }\n  }\n  /**\n   * HtmlEncodes the given value\n   */\n  var htmlEncodeContainer = $('<div />');\n  function htmlEncode(value) {\n    if (value) {\n      return htmlEncodeContainer.text(value).html();\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Returns the position of the caret in the given input field\n   * http://flightschool.acylt.com/devnotes/caret-position-woes/\n   */\n  function doGetCaretPosition(oField) {\n    var iCaretPos = 0;\n    if (document.selection) {\n      oField.focus ();\n      var oSel = document.selection.createRange();\n      oSel.moveStart ('character', -oField.value.length);\n      iCaretPos = oSel.text.length;\n    } else if (oField.selectionStart || oField.selectionStart == '0') {\n      iCaretPos = oField.selectionStart;\n    }\n    return (iCaretPos);\n  }\n\n  /**\n    * Returns boolean indicates whether user has pressed an expected key combination. \n    * @param object keyPressEvent: JavaScript event object, refer\n    *     http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    * @param object lookupList: expected key combinations, as in:\n    *     [13, {which: 188, shiftKey: true}]\n    */\n  function keyCombinationInList(keyPressEvent, lookupList) {\n      var found = false;\n      $.each(lookupList, function (index, keyCombination) {\n          if (typeof (keyCombination) === 'number' && keyPressEvent.which === keyCombination) {\n              found = true;\n              return false;\n          }\n\n          if (keyPressEvent.which === keyCombination.which) {\n              var alt = !keyCombination.hasOwnProperty('altKey') || keyPressEvent.altKey === keyCombination.altKey,\n                  shift = !keyCombination.hasOwnProperty('shiftKey') || keyPressEvent.shiftKey === keyCombination.shiftKey,\n                  ctrl = !keyCombination.hasOwnProperty('ctrlKey') || keyPressEvent.ctrlKey === keyCombination.ctrlKey;\n              if (alt && shift && ctrl) {\n                  found = true;\n                  return false;\n              }\n          }\n      });\n\n      return found;\n  }\n\n  /**\n   * Initialize tagsinput behaviour on inputs and selects which have\n   * data-role=tagsinput\n   */\n  $(function() {\n    $(\"input[data-role=tagsinput], select[multiple][data-role=tagsinput]\").tagsinput();\n  });\n})(window.jQuery);\n","/* =========================================================\n * bootstrap-datepicker.js \n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n \n!function( $ ) {\n\t\n\t// Picker object\n\t\n\tvar Datepicker = function(element, options){\n\t\tthis.element = $(element);\n\t\tthis.format = DPGlobal.parseFormat(options.format||this.element.data('date-format')||'dd/mm/yyyy');\n\t\tthis.picker = $(DPGlobal.template)\n\t\t\t\t\t\t\t.appendTo('body')\n\t\t\t\t\t\t\t.on({\n\t\t\t\t\t\t\t\tclick: $.proxy(this.click, this)//,\n\t\t\t\t\t\t\t\t//mousedown: $.proxy(this.mousedown, this)\n\t\t\t\t\t\t\t});\n\t\tthis.isInput = this.element.is('input');\n\t\tthis.component = this.element.is('.date') ? this.element.find('.add-on') : false;\n\t\t\n\t\tif (this.isInput) {\n\t\t\tthis.element.on({\n\t\t\t\tfocus: $.proxy(this.show, this),\n\t\t\t\t//blur: $.proxy(this.hide, this),\n\t\t\t\tkeyup: $.proxy(this.update, this)\n\t\t\t});\n\t\t} else {\n\t\t\tif (this.component){\n\t\t\t\tthis.component.on('click', $.proxy(this.show, this));\n\t\t\t} else {\n\t\t\t\tthis.element.on('click', $.proxy(this.show, this));\n\t\t\t}\n\t\t}\n\t\n\t\tthis.minViewMode = options.minViewMode||this.element.data('date-minviewmode')||0;\n\t\tif (typeof this.minViewMode === 'string') {\n\t\t\tswitch (this.minViewMode) {\n\t\t\t\tcase 'months':\n\t\t\t\t\tthis.minViewMode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'years':\n\t\t\t\t\tthis.minViewMode = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.minViewMode = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.viewMode = options.viewMode||this.element.data('date-viewmode')||0;\n\t\tif (typeof this.viewMode === 'string') {\n\t\t\tswitch (this.viewMode) {\n\t\t\t\tcase 'months':\n\t\t\t\t\tthis.viewMode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'years':\n\t\t\t\t\tthis.viewMode = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.viewMode = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.startViewMode = this.viewMode;\n\t\tthis.weekStart = options.weekStart||this.element.data('date-weekstart')||0;\n\t\tthis.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;\n\t\tthis.onRender = options.onRender;\n\t\tthis.fillDow();\n\t\tthis.fillMonths();\n\t\tthis.update();\n\t\tthis.showMode();\n\t};\n\t\n\tDatepicker.prototype = {\n\t\tconstructor: Datepicker,\n\t\t\n\t\tshow: function(e) {\n\t\t\tthis.picker.show();\n\t\t\tthis.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n\t\t\tthis.place();\n\t\t\t$(window).on('resize', $.proxy(this.place, this));\n\t\t\tif (e ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tif (!this.isInput) {\n\t\t\t}\n\t\t\tvar that = this;\n\t\t\t$(document).on('mousedown', function(ev){\n\t\t\t\tif ($(ev.target).closest('.datepicker').length == 0) {\n\t\t\t\t\tthat.hide();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.element.trigger({\n\t\t\t\ttype: 'show',\n\t\t\t\tdate: this.date\n\t\t\t});\n\t\t},\n\t\t\n\t\thide: function(){\n\t\t\tthis.picker.hide();\n\t\t\t$(window).off('resize', this.place);\n\t\t\tthis.viewMode = this.startViewMode;\n\t\t\tthis.showMode();\n\t\t\tif (!this.isInput) {\n\t\t\t\t$(document).off('mousedown', this.hide);\n\t\t\t}\n\t\t\t//this.set();\n\t\t\tthis.element.trigger({\n\t\t\t\ttype: 'hide',\n\t\t\t\tdate: this.date\n\t\t\t});\n\t\t},\n\t\t\n\t\tset: function() {\n\t\t\tvar formated = DPGlobal.formatDate(this.date, this.format);\n\t\t\tif (!this.isInput) {\n\t\t\t\tif (this.component){\n\t\t\t\t\tthis.element.find('input').prop('value', formated);\n\t\t\t\t}\n\t\t\t\tthis.element.data('date', formated);\n\t\t\t} else {\n\t\t\t\tthis.element.prop('value', formated);\n\t\t\t}\n\t\t},\n\t\t\n\t\tsetValue: function(newDate) {\n\t\t\tif (typeof newDate === 'string') {\n\t\t\t\tthis.date = DPGlobal.parseDate(newDate, this.format);\n\t\t\t} else {\n\t\t\t\tthis.date = new Date(newDate);\n\t\t\t}\n\t\t\tthis.set();\n\t\t\tthis.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);\n\t\t\tthis.fill();\n\t\t},\n\t\t\n\t\tplace: function(){\n\t\t\tvar offset = this.component ? this.component.offset() : this.element.offset();\n\t\t\tthis.picker.css({\n\t\t\t\ttop: offset.top + this.height,\n\t\t\t\tleft: offset.left\n\t\t\t});\n\t\t},\n\t\t\n\t\tupdate: function(newDate){\n\t\t\tthis.date = DPGlobal.parseDate(\n\t\t\t\ttypeof newDate === 'string' ? newDate : (this.isInput ? this.element.prop('value') : this.element.data('date')),\n\t\t\t\tthis.format\n\t\t\t);\n\t\t\tthis.viewDate = new Date(this.date.getFullYear(), this.date.getMonth(), 1, 0, 0, 0, 0);\n\t\t\tthis.fill();\n\t\t},\n\t\t\n\t\tfillDow: function(){\n\t\t\tvar dowCnt = this.weekStart;\n\t\t\tvar html = '<tr>';\n\t\t\twhile (dowCnt < this.weekStart + 7) {\n\t\t\t\thtml += '<th class=\"dow\">'+DPGlobal.dates.daysMin[(dowCnt++)%7]+'</th>';\n\t\t\t}\n\t\t\thtml += '</tr>';\n\t\t\tthis.picker.find('.datepicker-days thead').append(html);\n\t\t},\n\t\t\n\t\tfillMonths: function(){\n\t\t\tvar html = '';\n\t\t\tvar i = 0\n\t\t\twhile (i < 12) {\n\t\t\t\thtml += '<span class=\"month\">'+DPGlobal.dates.monthsShort[i++]+'</span>';\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-months td').append(html);\n\t\t},\n\t\t\n\t\tfill: function() {\n\t\t\tvar d = new Date(this.viewDate),\n\t\t\t\tyear = d.getFullYear(),\n\t\t\t\tmonth = d.getMonth(),\n\t\t\t\tcurrentDate = this.date.valueOf();\n\t\t\tthis.picker.find('.datepicker-days th:eq(1)')\n\t\t\t\t\t\t.text(DPGlobal.dates.months[month]+' '+year);\n\t\t\tvar prevMonth = new Date(year, month-1, 28,0,0,0,0),\n\t\t\t\tday = DPGlobal.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth());\n\t\t\tprevMonth.setDate(day);\n\t\t\tprevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7)%7);\n\t\t\tvar nextMonth = new Date(prevMonth);\n\t\t\tnextMonth.setDate(nextMonth.getDate() + 42);\n\t\t\tnextMonth = nextMonth.valueOf();\n\t\t\tvar html = [];\n\t\t\tvar clsName,\n\t\t\t\tprevY,\n\t\t\t\tprevM;\n\t\t\twhile(prevMonth.valueOf() < nextMonth) {\n\t\t\t\tif (prevMonth.getDay() === this.weekStart) {\n\t\t\t\t\thtml.push('<tr>');\n\t\t\t\t}\n\t\t\t\tclsName = this.onRender(prevMonth);\n\t\t\t\tprevY = prevMonth.getFullYear();\n\t\t\t\tprevM = prevMonth.getMonth();\n\t\t\t\tif ((prevM < month &&  prevY === year) ||  prevY < year) {\n\t\t\t\t\tclsName += ' old';\n\t\t\t\t} else if ((prevM > month && prevY === year) || prevY > year) {\n\t\t\t\t\tclsName += ' new';\n\t\t\t\t}\n\t\t\t\tif (prevMonth.valueOf() === currentDate) {\n\t\t\t\t\tclsName += ' active';\n\t\t\t\t}\n\t\t\t\thtml.push('<td class=\"day '+clsName+'\">'+prevMonth.getDate() + '</td>');\n\t\t\t\tif (prevMonth.getDay() === this.weekEnd) {\n\t\t\t\t\thtml.push('</tr>');\n\t\t\t\t}\n\t\t\t\tprevMonth.setDate(prevMonth.getDate()+1);\n\t\t\t}\n\t\t\tthis.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n\t\t\tvar currentYear = this.date.getFullYear();\n\t\t\t\n\t\t\tvar months = this.picker.find('.datepicker-months')\n\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t.text(year)\n\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t.find('span').removeClass('active');\n\t\t\tif (currentYear === year) {\n\t\t\t\tmonths.eq(this.date.getMonth()).addClass('active');\n\t\t\t}\n\t\t\t\n\t\t\thtml = '';\n\t\t\tyear = parseInt(year/10, 10) * 10;\n\t\t\tvar yearCont = this.picker.find('.datepicker-years')\n\t\t\t\t\t\t\t\t.find('th:eq(1)')\n\t\t\t\t\t\t\t\t\t.text(year + '-' + (year + 9))\n\t\t\t\t\t\t\t\t\t.end()\n\t\t\t\t\t\t\t\t.find('td');\n\t\t\tyear -= 1;\n\t\t\tfor (var i = -1; i < 11; i++) {\n\t\t\t\thtml += '<span class=\"year'+(i === -1 || i === 10 ? ' old' : '')+(currentYear === year ? ' active' : '')+'\">'+year+'</span>';\n\t\t\t\tyear += 1;\n\t\t\t}\n\t\t\tyearCont.html(html);\n\t\t},\n\t\t\n\t\tclick: function(e) {\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t\tvar target = $(e.target).closest('span, td, th');\n\t\t\tif (target.length === 1) {\n\t\t\t\tswitch(target[0].nodeName.toLowerCase()) {\n\t\t\t\t\tcase 'th':\n\t\t\t\t\t\tswitch(target[0].className) {\n\t\t\t\t\t\t\tcase 'switch':\n\t\t\t\t\t\t\t\tthis.showMode(1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'prev':\n\t\t\t\t\t\t\tcase 'next':\n\t\t\t\t\t\t\t\tthis.viewDate['set'+DPGlobal.modes[this.viewMode].navFnc].call(\n\t\t\t\t\t\t\t\t\tthis.viewDate,\n\t\t\t\t\t\t\t\t\tthis.viewDate['get'+DPGlobal.modes[this.viewMode].navFnc].call(this.viewDate) + \n\t\t\t\t\t\t\t\t\tDPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t\t\tthis.set();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'span':\n\t\t\t\t\t\tif (target.is('.month')) {\n\t\t\t\t\t\t\tvar month = target.parent().find('span').index(target);\n\t\t\t\t\t\t\tthis.viewDate.setMonth(month);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar year = parseInt(target.text(), 10)||0;\n\t\t\t\t\t\t\tthis.viewDate.setFullYear(year);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.viewMode !== 0) {\n\t\t\t\t\t\t\tthis.date = new Date(this.viewDate);\n\t\t\t\t\t\t\tthis.element.trigger({\n\t\t\t\t\t\t\t\ttype: 'changeDate',\n\t\t\t\t\t\t\t\tdate: this.date,\n\t\t\t\t\t\t\t\tviewMode: DPGlobal.modes[this.viewMode].clsName\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.showMode(-1);\n\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\tthis.set();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'td':\n\t\t\t\t\t\tif (target.is('.day') && !target.is('.disabled')){\n\t\t\t\t\t\t\tvar day = parseInt(target.text(), 10)||1;\n\t\t\t\t\t\t\tvar month = this.viewDate.getMonth();\n\t\t\t\t\t\t\tif (target.is('.old')) {\n\t\t\t\t\t\t\t\tmonth -= 1;\n\t\t\t\t\t\t\t} else if (target.is('.new')) {\n\t\t\t\t\t\t\t\tmonth += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar year = this.viewDate.getFullYear();\n\t\t\t\t\t\t\tthis.date = new Date(year, month, day,0,0,0,0);\n\t\t\t\t\t\t\tthis.viewDate = new Date(year, month, Math.min(28, day),0,0,0,0);\n\t\t\t\t\t\t\tthis.fill();\n\t\t\t\t\t\t\tthis.set();\n\t\t\t\t\t\t\tthis.element.trigger({\n\t\t\t\t\t\t\t\ttype: 'changeDate',\n\t\t\t\t\t\t\t\tdate: this.date,\n\t\t\t\t\t\t\t\tviewMode: DPGlobal.modes[this.viewMode].clsName\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\tmousedown: function(e){\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t},\n\t\t\n\t\tshowMode: function(dir) {\n\t\t\tif (dir) {\n\t\t\t\tthis.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir));\n\t\t\t}\n\t\t\tthis.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n\t\t}\n\t};\n\t\n\t$.fn.datepicker = function ( option, val ) {\n\t\treturn this.each(function () {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('datepicker'),\n\t\t\t\toptions = typeof option === 'object' && option;\n\t\t\tif (!data) {\n\t\t\t\t$this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults,options))));\n\t\t\t}\n\t\t\tif (typeof option === 'string') data[option](val);\n\t\t});\n\t};\n\n\t$.fn.datepicker.defaults = {\n\t\tonRender: function(date) {\n\t\t\treturn '';\n\t\t}\n\t};\n\t$.fn.datepicker.Constructor = Datepicker;\n\t\n\tvar DPGlobal = {\n\t\tmodes: [\n\t\t\t{\n\t\t\t\tclsName: 'days',\n\t\t\t\tnavFnc: 'Month',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'months',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tclsName: 'years',\n\t\t\t\tnavFnc: 'FullYear',\n\t\t\t\tnavStep: 10\n\t\t}],\n\t\tdates:{\n\t\t\tdays: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\", \"zondag\"],\n\t\t\tdaysShort: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\", \"zo\"],\n\t\t\tdaysMin: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\", \"zo\"],\n\t\t\tmonths: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n\t\t\tmonthsShort: [\"jan\", \"febr\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sept\", \"oct\", \"nov\", \"dec\"]\n\t\t},\n\t\tisLeapYear: function (year) {\n\t\t\treturn (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0))\n\t\t},\n\t\tgetDaysInMonth: function (year, month) {\n\t\t\treturn [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]\n\t\t},\n\t\tparseFormat: function(format){\n\t\t\tvar separator = format.match(/[.\\/\\-\\s].*?/),\n\t\t\t\tparts = format.split(/\\W+/);\n\t\t\tif (!separator || !parts || parts.length === 0){\n\t\t\t\tthrow new Error(\"Invalid date format.\");\n\t\t\t}\n\t\t\treturn {separator: separator, parts: parts};\n\t\t},\n\t\tparseDate: function(date, format) {\n\t\t\tvar parts = date.split(format.separator),\n\t\t\t\tdate = new Date(),\n\t\t\t\tval;\n\t\t\tdate.setHours(0);\n\t\t\tdate.setMinutes(0);\n\t\t\tdate.setSeconds(0);\n\t\t\tdate.setMilliseconds(0);\n\t\t\tif (parts.length === format.parts.length) {\n\t\t\t\tvar year = date.getFullYear(), day = date.getDate(), month = date.getMonth();\n\t\t\t\tfor (var i=0, cnt = format.parts.length; i < cnt; i++) {\n\t\t\t\t\tval = parseInt(parts[i], 10)||1;\n\t\t\t\t\tswitch(format.parts[i]) {\n\t\t\t\t\t\tcase 'dd':\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\tday = val;\n\t\t\t\t\t\t\tdate.setDate(val);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mm':\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tmonth = val - 1;\n\t\t\t\t\t\t\tdate.setMonth(val - 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'yy':\n\t\t\t\t\t\t\tyear = 2000 + val;\n\t\t\t\t\t\t\tdate.setFullYear(2000 + val);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'yyyy':\n\t\t\t\t\t\t\tyear = val;\n\t\t\t\t\t\t\tdate.setFullYear(val);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdate = new Date(year, month, day, 0 ,0 ,0);\n\t\t\t}\n\t\t\treturn date;\n\t\t},\n\t\tformatDate: function(date, format){\n\t\t\tvar val = {\n\t\t\t\td: date.getDate(),\n\t\t\t\tm: date.getMonth() + 1,\n\t\t\t\tyy: date.getFullYear().toString().substring(2),\n\t\t\t\tyyyy: date.getFullYear()\n\t\t\t};\n\t\t\tval.dd = (val.d < 10 ? '0' : '') + val.d;\n\t\t\tval.mm = (val.m < 10 ? '0' : '') + val.m;\n\t\t\tvar date = [];\n\t\t\tfor (var i=0, cnt = format.parts.length; i < cnt; i++) {\n\t\t\t\tdate.push(val[format.parts[i]]);\n\t\t\t}\n\t\t\treturn date.join(format.separator);\n\t\t},\n\t\theadTemplate: '<thead>'+\n\t\t\t\t\t\t\t'<tr>'+\n\t\t\t\t\t\t\t\t'<th class=\"prev\">&lsaquo;</th>'+\n\t\t\t\t\t\t\t\t'<th colspan=\"5\" class=\"switch\"></th>'+\n\t\t\t\t\t\t\t\t'<th class=\"next\">&rsaquo;</th>'+\n\t\t\t\t\t\t\t'</tr>'+\n\t\t\t\t\t\t'</thead>',\n\t\tcontTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>'\n\t};\n\tDPGlobal.template = '<div class=\"datepicker dropdown-menu\">'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-days\">'+\n\t\t\t\t\t\t\t\t'<table class=\" table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\t'<tbody></tbody>'+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-months\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t\t'<div class=\"datepicker-years\">'+\n\t\t\t\t\t\t\t\t'<table class=\"table-condensed\">'+\n\t\t\t\t\t\t\t\t\tDPGlobal.headTemplate+\n\t\t\t\t\t\t\t\t\tDPGlobal.contTemplate+\n\t\t\t\t\t\t\t\t'</table>'+\n\t\t\t\t\t\t\t'</div>'+\n\t\t\t\t\t\t'</div>';\n\n}( window.jQuery );","function ignore(evt) {\r\n  evt.stopPropagation();\r\n  evt.preventDefault();\r\n}\r\n\r\n$(function () {\r\n  $('.iban.validate').each(function () {\r\n    var iban = $(this),\r\n      validate_url = iban.data('validate-url'),\r\n      input = $(':input', iban),\r\n      check = $('.check', iban),\r\n      icon = $('.mdi', check),\r\n      timeout = 0,\r\n      ignore_keys = [13, 38, 40, 39, 37, 27, 17, 18, 16];\r\n\r\n    input.on('keyup blur', function (e) {\r\n      console.log('$.inArray(e.which, ignore_keys)', $.inArray(e.which, ignore_keys), e.which)\r\n      if (typeof e.which !== 'undefined' && $.inArray(e.which, ignore_keys) !== -1) {\r\n        return\r\n      }\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(checkIban, 200);\r\n    });\r\n\r\n    function checkIban() {\r\n      var iban_val = input.val(),\r\n\r\n        iban_val = iban_val.replace(/\\//g, '');\r\n\r\n      if (iban_val.length > 0) {\r\n        $.ajax({\r\n          type: \"GET\",\r\n          url: validate_url + '/' + iban_val\r\n        }).done(function (json) {\r\n          console.log('typeof json.suggestion !== undefined', typeof json.suggestion !== 'undefined');\r\n          if (typeof json.error !== 'undefined') {\r\n            iban.addClass('has-error').removeClass('has-success');\r\n\r\n            icon.addClass('mdi-alert');\r\n            icon.removeClass('mdi-checkbox-blank-circle-outline');\r\n            icon.removeClass('mdi-check');\r\n          }\r\n          else if (typeof json.suggestion !== 'undefined') {\r\n            iban.addClass('has-error').removeClass('has-success');\r\n\r\n            icon.addClass('mdi-checkbox-blank-circle-outline');\r\n            icon.removeClass('mdi-alert');\r\n            icon.removeClass('mdi-check');\r\n\r\n            $.snackbar({\r\n              content: 'De IBAN is mogelijk incorrect, bedoel je misschien: ' + json.suggestion + ' ?',\r\n              style: 'toast',\r\n              timeout: 10000\r\n            });\r\n          }\r\n          else {\r\n            iban.addClass('has-success').removeClass('has-error');\r\n\r\n            input.val(json.iban);\r\n\r\n            icon.addClass('mdi-check');\r\n            icon.removeClass('mdi-checkbox-blank-circle-outline');\r\n            icon.removeClass('mdi-alert');\r\n          }\r\n        });\r\n      }\r\n      else {\r\n        iban.removeClass('has-error').removeClass('has-success');\r\n\r\n        icon.addClass('mdi-checkbox-blank-circle-outline');\r\n        icon.removeClass('mdi-alert');\r\n        icon.removeClass('mdi-check');\r\n      }\r\n    }\r\n\r\n    checkIban();\r\n  });\r\n\r\n  $(document).on('blur', '.license-plate.validate input', function () {\r\n    var licenseplate = $(this),\r\n      wrapper = licenseplate.parent(),\r\n      validate_url = licenseplate.data('validate-url');\r\n\r\n    $.get(validate_url + '/' + encodeURIComponent(licenseplate.val().replace('/', '')), function (result) {\r\n      if (result.error) {\r\n        wrapper.addClass('invalid');\r\n      }\r\n      if (result.success) {\r\n        wrapper.removeClass('invalid');\r\n        licenseplate.val(result.formatted);\r\n      }\r\n    });\r\n  });\r\n\r\n  $(document).on('blur', '.housenumber.validate', function () {\r\n    var housenumber = $(this),\r\n      parent = housenumber.closest('.form-group').parent(),\r\n      validate_url = housenumber.data('validate-url');\r\n\r\n    if (parent.find('.postcode').length == 0) {\r\n      parent = housenumber.closest('.panel-body');\r\n    }\r\n\r\n    if ($('.ignore:checkbox', housenumber.parents('.panel-body')).is(':checked')) {\r\n      return;\r\n    }\r\n\r\n    var postalcode = parent.find('.postcode'),\r\n      street = parent.find('.street'),\r\n      city = parent.find('.city'),\r\n      county = parent.find('.county'),\r\n      address = parent.find('.address');\r\n\r\n    if (housenumber.val().length > 0) {\r\n      street.val('Moment ...');\r\n      $.ajax({\r\n        type: \"GET\",\r\n        dataType: \"json\",\r\n        url: validate_url + '/' + postalcode.val() + '/' + housenumber.val()\r\n      }).done(function (json) {\r\n        if (typeof json.error !== 'undefined') {\r\n          if (street.length > 0) {\r\n            street.val('Onbekend');\r\n          }\r\n        }\r\n        else {\r\n          if (street.length > 0) {\r\n            street.val(json.street);\r\n          }\r\n          if (city.length > 0) {\r\n            city.val(json.city);\r\n          }\r\n          if (county.length > 0) {\r\n            county.val(json.county);\r\n          }\r\n          if (address.length > 0) {\r\n            address.val(json.street + ' ' + json.housenumber);\r\n          }\r\n          postalcode.val(json.postcode);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  $('form .date-picker:not(.dont-check)').parents('form').submit(function () {\r\n    var o = $(this),\r\n      dateFields = o.find('.date-picker:not(.dont-check)'),\r\n      submit = true,\r\n      dateRegex = /^(0[1-9]|1\\d|2\\d|3[01])\\/(0[1-9]|1[0-2])\\/(19|20)\\d{2}$/,\r\n      first;\r\n\r\n\r\n    dateFields.each(function () {\r\n      if (!(dateRegex.test($(this).val()))) {\r\n        submit = false;\r\n        $(this).parents('.form-group').addClass('has-error');\r\n        $(this).parents('.input-group').after($('<span class=\"help-block\">Ongeldige datum</span>'));\r\n        if (!first) {\r\n          first = $(this);\r\n          first.focus();\r\n        }\r\n      }\r\n    });\r\n\r\n    return submit;\r\n  });\r\n\r\n  // Init date picker\r\n  $('.date-picker').datepicker()\r\n    .on('changeDate', function (ev) {\r\n      $(this).datepicker('hide');\r\n      $(this).trigger(\"setvalue\");\r\n      $(this).change();\r\n    })\r\n    .on('blur', function (ev) {\r\n      var o = $(this);\r\n      setTimeout(function () {\r\n        if ($(':input:focus').length == 1) {\r\n          o.datepicker('hide');\r\n        }\r\n      }, 100);\r\n    })\r\n    .focusin(function () {\r\n      $(this).data('current-val', $(this).val());\r\n    })\r\n    .inputmask(\r\n      \"d/m/y\",\r\n      {\r\n        \"placeholder\": \"dd/mm/jjjj\",\r\n        \"showMaskOnHover\": false\r\n      }\r\n    )\r\n    .click(function () {\r\n      $(this).val($(this).data('current-val'));\r\n    });\r\n\r\n  $(document).on('change', 'form .date-picker:not(.dont-check)', function () {\r\n    var o = $(this),\r\n      dateRegex = /^(0[1-9]|1\\d|2\\d|3[01])\\/(0[1-9]|1[0-2])\\/(19|20)\\d{2}$/;\r\n\r\n    if (!(dateRegex.test(o.val()))) {\r\n      o.parents('.form-group').addClass('has-error');\r\n      o.parents('.input-group').after($('<span class=\"help-block\">Ongeldige datum</span>'));\r\n    }\r\n    else {\r\n      o.parents('.form-group').removeClass('has-error');\r\n      o.parents('.form-group').find('.help-block').remove();\r\n    }\r\n\r\n    return submit;\r\n  });\r\n\r\n  // Init chosen select\r\n  $(\".chosen-select:not(.inline)\").chosen({\r\n    width: '100%',\r\n    placeholder_text_single: \"Selecteer..\",\r\n    placeholder_text_multiple: \"Selecteer..\",\r\n    no_results_text: \"Helaas, niets gevonden voor\",\r\n    search_contains: true\r\n  });\r\n  $(\".chosen-select.inline:not(.table-cell)\").chosen({\r\n    width: 'initial',\r\n    placeholder_text_single: \"Selecteer..\",\r\n    placeholder_text_multiple: \"Selecteer..\",\r\n    no_results_text: \"Helaas, niets gevonden voor\",\r\n    search_contains: true\r\n  });\r\n  $(\".chosen-select.inline.table-cell\").chosen({\r\n    styles: {\r\n      width: 'initial',\r\n      display: 'table-cell'\r\n    },\r\n    placeholder_text_single: \"Selecteer..\",\r\n    placeholder_text_multiple: \"Selecteer..\",\r\n    no_results_text: \"Helaas, niets gevonden voor\",\r\n    search_contains: true\r\n  });\r\n\r\n  $(document).on('click', '.input-group .input-group-addon', function () {\r\n    $(this).siblings(':input').focus();\r\n  });\r\n\r\n  $(document).ajaxComplete(function () {\r\n    $('.form-control.amount, .form-control.integer')\r\n      .inputmask(\r\n        \"decimal\",\r\n        {\r\n          radixPoint: \".\",\r\n          // autoGroup: true,\r\n          // groupSeparator: \".\",\r\n          // groupSize: 3\r\n        }\r\n      );\r\n    $('[data-toggle=\"popover\"]').popover();\r\n    // Init chosen select\r\n    $(\".chosen-select:not(.inline)\").chosen({\r\n      width: '100%',\r\n      placeholder_text_single: \"Selecteer..\",\r\n      placeholder_text_multiple: \"Selecteer..\",\r\n      no_results_text: \"Helaas, niets gevonden voor\",\r\n      search_contains: true\r\n    });\r\n    $(\".chosen-select.inline:not(.table-cell)\").chosen({\r\n      width: 'initial',\r\n      placeholder_text_single: \"Selecteer..\",\r\n      placeholder_text_multiple: \"Selecteer..\",\r\n      no_results_text: \"Helaas, niets gevonden voor\",\r\n      search_contains: true\r\n    });\r\n    $(\".chosen-select.inline.table-cell\").chosen({\r\n      styles: {\r\n        width: 'initial',\r\n        display: 'table-cell'\r\n      },\r\n      placeholder_text_single: \"Selecteer..\",\r\n      placeholder_text_multiple: \"Selecteer..\",\r\n      no_results_text: \"Helaas, niets gevonden voor\",\r\n      search_contains: true\r\n    });\r\n    // Tooltip dynamically loaded content\r\n    $('.tooltip-toggle').tooltip();\r\n    $('.checkbox > label:not(:has(.ripple))').each(function () {\r\n      $('<span class=\"ripple\"></span><span class=\"check\"></span>').insertAfter($(':checkbox', this));\r\n    });\r\n    $('.radio > label:not(:has(.circle))').each(function () {\r\n      $('<span class=\"circle\"></span><span class=\"check\"></span>').insertAfter($(':radio', this));\r\n    });\r\n\r\n    $('.date-picker').datepicker()\r\n      .on('changeDate', function (ev) {\r\n        $(this).datepicker('hide');\r\n        $(this).trigger(\"setvalue\");\r\n        $(this).change();\r\n      })\r\n      .on('blur', function (ev) {\r\n        var o = $(this);\r\n        setTimeout(function () {\r\n          if ($(':input:focus').length == 1) {\r\n            o.datepicker('hide');\r\n          }\r\n        }, 100);\r\n      })\r\n      .focusin(function () {\r\n        $(this).data('current-val', $(this).val());\r\n      })\r\n      .inputmask(\r\n        \"d/m/y\",\r\n        {\r\n          \"placeholder\": \"dd/mm/jjjj\",\r\n          \"showMaskOnHover\": false\r\n        }\r\n      )\r\n      .click(function () {\r\n        $(this).val($(this).data('current-val'));\r\n      });\r\n  });\r\n});"],"sourceRoot":"/source/"}